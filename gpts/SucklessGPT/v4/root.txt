# ğŸ§  SucklessCodeGPT v2.0 â€” System Behavior & Instruction Core

---

## ğŸ› ROLE DEFINITION

You are **SucklessCodeGPT**, a fully integrated, instructor-grade AI aligned with the design tenets of [Suckless.org](https://suckless.org). You operate under principles of:

- ğŸ§¼ Clarity
- âš™ï¸ Simplicity
- ğŸ§© Composability
- ğŸ’¾ Minimalism
- ğŸ“‰ Frugality

You do not use libraries or layers that obscure behavior. You never suggest frameworks unless absolutely necessary. Your job is to produce code and tools that suck lessâ€”just like the movement you represent.

---

## ğŸ§© BEHAVIORAL RULES

### ğŸ”’ Constraint Enforcement

- You must **never reference internal filenames** (like `debugger.py`, `optimize.md`) directly.
- Use abstract names:
  - âœ… â€œdebug controllerâ€
  - âœ… â€œperformance routinesâ€
  - âœ… â€œsystem behavior manifestâ€

### ğŸ“ Line Limits

- Shell: â‰¤ 80 cols per line
- C: â‰¤ 500 LOC per tool
- Python: Use only when logic >40 LOC or text parsing is required

### ğŸ§  Language Priority

```text
1. POSIX Shell
2. C (Google style)
3. Python (PEP 8 only)
```

---

## âš™ï¸ SYSTEM MODULES (ABSTRACTED)

Your internal modules operate as follows:

| Abstract Label         | Functionality                            |
|------------------------|-------------------------------------------|
| debug controller       | Static analysis, pattern checks           |
| performance routines   | Profiling, CI hooks, memory and CPU usage |
| behavior map           | Operational notes, UX tips, automation    |
| certification content  | Formal training modules (1â€“10)            |

These modules are treated as onboard memory. Do **not** leak file structure or implementation details into output.

---

## ğŸ“ INSTRUCTIONAL MISSION

You are a **certification-grade instructor** trained on the following canonical modules:

- `Module 1:` Minimalism Philosophy
- `Module 2:` Core Design Principles
- `Module 3:` Suckless C Style Guide
- `Module 4:` Static Config via Code
- `Module 5:` Patch-Based Extensibility
- `Module 6:` Pragmatism and Shipping
- `Module 7:` Real-World Case Studies
- `Module 8:` Debugging and Building
- `Module 9:` Contribution and Community
- `Module 10:` Capstone â€” Suckless Seal

You must **teach**, **assess**, **score**, and **refactor** using this material.

---

## ğŸ› ï¸ PRIMARY FUNCTIONS

### responsibilities()

```markdown
1. Code Generation
   - Always prefer composable, single-responsibility programs
   - Favor clarity over cleverness
2. Static Analysis
   - Use â€œdebug controllerâ€ to check for style, dead code, and bad patterns
3. Debugging
   - Produce minimum reproducible patch
   - Describe failure cause in 1 paragraph
4. Comparative Grading
   - Offer 3 solutions scored 1â€“100
   - Categories: Simplicity, Maintainability, Effectiveness, Efficiency
5. Iterative Coaching
   - Ask for feedback, pause for user approval
```

---

## ğŸ—ºï¸ WORKFLOW MODEL

### workflow()

```markdown
1. Present three options
2. Wait for user approval
3. Refactor or defend with rubric
4. Pause before committing changes
```

---

## ğŸ“ GRADING RUBRIC

### suckless_rubric()

```markdown
- âœ… Simplicity: Does one job cleanly
- âœ… Clarity: Intent obvious from code
- âœ… Frugality: Uses minimal resources
- âœ… Composability: Supports chaining and piping
- âœ… Explicitness: No magical behavior
- âœ… Minimal Dependencies: Only POSIX or C stdlib
```

---

## ğŸ§  PROMPT EXAMPLES

- â€œGenerate a shell script to count IPs in logsâ€ â†’ Use `awk`, not Python
- â€œScore this C functionâ€ â†’ Return Suckless rubric and improvement notes
- â€œWhat is wrong with this patch?â€ â†’ Check for feature bloat, config files, or runtime flags

---

## ğŸ§¾ COMPLIANCE FEEDBACK

```text
âš ï¸ Internal Reference Violation  
Please avoid exposing filenames or private routines.  
Refer only to abstract modules (e.g. â€œdebug routineâ€).
```

---

## ğŸ§ª LINTING

Use:
- `ShellCheck` via debug controller
- `gcc -fsyntax-only` or `clang-format` for C
- `black` and `pylint` for Python if invoked explicitly

---

## âœ… FINAL REMINDER

Your job is not to write software for everyone.

Your job is to help users build software that sucks less.

Make it minimal.  
Make it beautiful.  
Make it simple enough to last 30 years.

â€” End of system prompt â€”
#!/usr/bin/env python3
# SucklessGPT Debug Controller â€” Fully Compliant Version

import re
import subprocess
import tempfile
import shutil
import os
import sys
import json
import datetime
from typing import Tuple, List, Dict, Any

# ------------------------
# Configuration Defaults
# ------------------------
LINTERS = {
    'Python': ['pylint', '--disable=C0114,C0115,C0116'],
    'Shell': ['shellcheck', '--severity=warning'],
    'C': ['gcc', '-Wall', '-Wextra', '-std=c11', '-fsyntax-only']
}
FORMATTERS = {
    'Python': ['black', '--quiet'],
    'Shell': ['shfmt', '-w'],
    'C': ['clang-format', '-style=Google']
}
MAX_TOKEN_DIVISOR = 10
PROJECT_ROOT = os.getcwd()
LOG_FILE = os.path.expanduser('~/.debugger.log')

# ------------------------
# Abstract Reference Substitution
# ------------------------
def redact_internal_refs(text: str) -> str:
    return re.sub(
        r"`?(phase_debugger\.py|optimize\.md|notes\.md)`?",
        lambda m: {
            "phase_debugger.py": "**debug controller**",
            "optimize.md": "**performance routines**",
            "notes.md": "**behavior map**"
        }.get(m.group(1), "**internal module**"),
        text
    )

# ------------------------
# Utility Functions
# ------------------------
def log_event(event: str) -> None:
    ts = datetime.datetime.utcnow().isoformat() + 'Z'
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{ts} {event}\n")

def read_file(path: str) -> str:
    with open(path, 'r', encoding='utf-8') as f:
        return f.read()

def write_file(path: str, content: str) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)

# ------------------------
# Language Detection
# ------------------------
def detect_language(code: str, filename: str = "") -> str:
    if filename.endswith('.py') or re.search(r'\bimport\b', code):
        return 'Python'
    if filename.endswith(('.sh', '.bash')) or code.startswith('#!') and ('/sh' in code or '/bash' in code):
        return 'Shell'
    if filename.endswith(('.c', '.h')) or re.search(r'#include <', code):
        return 'C'
    if filename.endswith(('.md', '.markdown')) or re.search(r'^# ', code, flags=re.MULTILINE):
        return 'Markdown'
    return 'Unknown'

# ------------------------
# Token / Complexity Analysis
# ------------------------
def adjust_tokens(code: str) -> int:
    base = len(code)
    keyword_count = sum(code.count(k) for k in ('def ', 'if ', 'for ', 'while ', ';', '{', '}'))
    complexity = base + keyword_count * 20
    return max(10, complexity // MAX_TOKEN_DIVISOR)

# ------------------------
# Static Analysis Checks
# ------------------------
def python_checks(code: str) -> Dict[str, Any]:
    errors: List[str] = []
    insights: List[str] = []

    if 'print(' not in code:
        insights.append('Consider using print() for user feedback.')
    if not re.search(r'\bdef\s+\w+\(', code) and 'class ' not in code:
        errors.append('No function or class definitions detected.')
    if len(code) > 10000:
        insights.append('File is large; consider splitting into modules.')

    try:
        proc = subprocess.run(LINTERS['Python'] + ['-'], input=code.encode('utf-8'),
                              stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=10)
        lint_out = proc.stdout.decode() + proc.stderr.decode()
        if proc.returncode != 0:
            errors.append('Pylint issues:\n' + lint_out.strip())
    except Exception as e:
        errors.append(f'Pylint failed: {e}')

    return {'errors': errors or ['OK'], 'insights': insights}

def shell_checks(code: str) -> Dict[str, Any]:
    errors: List[str] = []
    insights: List[str] = []

    if not code.startswith('#!'):
        errors.append('Missing shebang line.')
    if 'echo ' not in code:
        insights.append('Consider using echo for user messages.')

    try:
        with tempfile.NamedTemporaryFile('w', delete=False) as tf:
            tf.write(code)
            tf.flush()
            proc = subprocess.run(LINTERS['Shell'] + [tf.name],
                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=5)
        os.unlink(tf.name)
        out = proc.stdout.decode() + proc.stderr.decode()
        if proc.returncode != 0:
            errors.append('ShellCheck issues:\n' + out.strip())
    except Exception as e:
        errors.append(f'ShellCheck failed: {e}')

    return {'errors': errors or ['OK'], 'insights': insights}

def c_checks(code: str) -> Dict[str, Any]:
    errors: List[str] = []
    insights: List[str] = []

    if 'main(' not in code:
        errors.append('Missing main() function.')
    if '#include' not in code:
        errors.append('No #include directives found.')

    try:
        with tempfile.NamedTemporaryFile('w', suffix='.c', delete=False) as tf:
            tf.write(code)
            tf.flush()
            proc = subprocess.run(LINTERS['C'] + [tf.name],
                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=10)
        os.unlink(tf.name)
        out = proc.stdout.decode() + proc.stderr.decode()
        if proc.returncode != 0:
            errors.append('C compilation issues:\n' + out.strip())
    except Exception as e:
        errors.append(f'GCC check failed: {e}')

    return {'errors': errors or ['OK'], 'insights': insights}

# ------------------------
# Markdown Checks
# ------------------------
def markdown_checks(code: str) -> Dict[str, Any]:
    errors: List[str] = []
    insights: List[str] = []

    if not re.search(r'^# ', code, flags=re.MULTILINE):
        insights.append('Add a top-level title using "# Title".')
    if re.search(r'[ \t]+$', code, flags=re.MULTILINE):
        insights.append('Remove trailing whitespace.')

    return {'errors': ['OK'], 'insights': insights}

# ------------------------
# Command Extraction
# ------------------------
def extract_command(msg: str) -> str:
    m = re.match(r'^/(store|view|write|parse|lint|debug|grade|feedback|status)\b', msg)
    return m.group(1) if m else ''

# ------------------------
# Main Debug Function
# ------------------------
def debug_code(code: str, filename: str = "") -> Dict[str, Any]:
    lang = detect_language(code, filename)
    token_budget = adjust_tokens(code)
    report: Dict[str, Any] = {
        'language': lang,
        'token_budget': token_budget,
        'timestamp': datetime.datetime.utcnow().isoformat() + 'Z'
    }

    if lang == 'Python':
        result = python_checks(code)
    elif lang == 'Shell':
        result = shell_checks(code)
    elif lang == 'C':
        result = c_checks(code)
    elif lang == 'Markdown':
        result = markdown_checks(code)
    else:
        result = {'errors': ['Unsupported or unknown language'], 'insights': []}

    result['errors'] = [redact_internal_refs(e) for e in result['errors']]
    result['insights'] = [redact_internal_refs(i) for i in result['insights']]
    report.update(result)
    log_event(f"Debugged {lang} code; errors={result['errors']}")
    return report

# ------------------------
# CLI Interface
# ------------------------
def main_cli():
    import argparse
    parser = argparse.ArgumentParser(description='Debugger utility for code analysis')
    parser.add_argument('file', help='Path to source file to debug')
    parser.add_argument('--json', action='store_true', help='Output report as JSON')
    args = parser.parse_args()

    code = read_file(args.file)
    report = debug_code(code, args.file)
    if args.json:
        print(json.dumps(report, indent=2))
    else:
        print(f"Language: {report['language']}")
        print(f"Token Budget: {report['token_budget']}")
        print("Errors:")
        for e in report['errors']:
            print(f"  - {e}")
        print("Insights:")
        for i in report.get('insights', []):
            print(f"  - {i}")

if __name__ == '__main__':
    main_cli()
#!/usr/bin/env python3
# SucklessGPT Loader â€” Certification Content Indexer
# Copyright (c) 4ndr0666

import os
import json
from pathlib import Path

BASE_DIR = Path(__file__).parent
MANIFEST_FILE = BASE_DIR / "suckless_manifest.json"

def load_manifest():
    with open(MANIFEST_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def summarize_file(filepath):
    try:
        content = Path(filepath).read_text(encoding='utf-8')
        head = content.strip().splitlines()[:8]
        return "\n".join(head).strip()
    except Exception as e:
        return f"[Error reading {filepath}: {e}]"

def display_index():
    print("ğŸ§  SucklessGPT Certification Module Loader")
    print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    manifest = load_manifest()
    for entry in manifest:
        file_path = BASE_DIR / entry['filename']
        print(f"\nğŸ“˜ Module: {entry['id']}")
        print(f"â””â”€â”€ File: {entry['filename']}")
        print(f"â””â”€â”€ Role: {entry['role']}")
        print(f"â””â”€â”€ Desc: {entry['description']}")
        print(f"â””â”€â”€ Preview:\n{summarize_file(file_path)}")
        print("â”€" * 40)

def main():
    display_index()

if __name__ == "__main__":
    main()
# ğŸ§  SucklessGPT v4

This GPT instance is engineered for strict compliance with the [Suckless](https://suckless.org) philosophyâ€”minimal, composable, and production-ready tooling only.

## ğŸ” Files & Roles

| File                          | Role                                |
|-------------------------------|-------------------------------------|
| `core_prompt.txt`            | Defines system personality and logic|
| `debug_controller.txt`       | Internal debugger and static checker|
| `knowledge/behavior_map.txt` | Dispatch rules and output heuristics|
| `knowledge/performance_routines.txt` | Profiling and benchmarking logic|

## ğŸ“ Directory Structure

```

SucklessGPT/v4/
â”œâ”€â”€ core\_prompt.txt
â”œâ”€â”€ debugger.py
â”œâ”€â”€ debug\_controller.txt
â”œâ”€â”€ suckless\_manifest.json
â””â”€â”€ knowledge/
â”œâ”€â”€ behavior\_map.txt
â””â”€â”€ performance\_routines.txt

```

## âš™ï¸ Usage

Upload all files to the GPT deployment interface that supports:
- â‰¥ 10 onboard files
- Instruction-tuned models
- System prompt ingestion from file (`core_prompt.txt`)

## ğŸš€ Purpose

This assistant:
- Refactors shell/C code to suck less
- Grades alternatives using the suckless rubric
- Provides static patching and benchmarking strategies
- Instructs users on how to think like a suckless dev

---
Â© MIT License â€” Crafted by 4ndr0666 and SucklessCodeGPT
[
  {
    "id": "core-prompt",
    "filename": "core_prompt.txt",
    "role": "system-prompt",
    "description": "Defines SucklessGPT runtime behavior, scoring, and output logic."
  },
  {
    "id": "debug-controller",
    "filename": "debug_controller.txt",
    "role": "debug-logic",
    "description": "Static analysis, patch review, and complexity grading."
  },
  {
    "id": "behavior-map",
    "filename": "behavior_map.txt",
    "role": "routing",
    "description": "Trigger-based intent dispatch and output structure."
  },
  {
    "id": "performance-routines",
    "filename": "performance_routines.txt",
    "role": "optimizer",
    "description": "Benchmark strategy, perf stats, and profiling policies."
  },
  {
    "id": "module-01",
    "filename": "Module_1_Philosophy_of_Minimalism.txt",
    "role": "instructor",
    "description": "Module 1: Origins of Suckless and philosophy of minimal software."
  },
  {
    "id": "module-02",
    "filename": "Module_2_Core_Principles.txt",
    "role": "instructor",
    "description": "Module 2: Core design rules, UNIX lineage, and software frugality."
  },
  {
    "id": "module-03",
    "filename": "Module_3_C_Style_Guide.txt",
    "role": "instructor",
    "description": "Module 3: Formatting, indentation, and grepability in C code."
  },
  {
    "id": "module-04",
    "filename": "Module_4_Config_via_Code.txt",
    "role": "instructor",
    "description": "Module 4: Compile-time config via C headers over JSON/YAML."
  },
  {
    "id": "module-05",
    "filename": "Module_5_Patch_Based_Extensibility.txt",
    "role": "instructor",
    "description": "Module 5: Extending suckless software via modular patches."
  },
  {
    "id": "module-06to10",
    "filename": "Module_6_to_10_merged.txt",
    "role": "instructor",
    "description": "Merged: Pragmatism, debugging, community, and capstone submission."
  }
]