# Fanvue Developer Platform

> The infrastructure for high-scale agencies and AI-first creator tools.

<div>
  {/* CSS OVERRIDES */}

  {/* BACKGROUND TEXTURES */}

  {/* HERO SECTION */}

  <div>
    <h1>
      Build the Future of <br />
      <span>Creator Monetization</span>
    </h1>

    <p>
      The infrastructure for high-scale agencies and AI-first creator tools. <br />
      Access the API driving the next generation of the creator economy.
    </p>

    <div>
      <a href="/docs/introduction/quick-start">
        <span>
          <i />

           Quick Start
        </span>
      </a>

      <a href="https://discord.com/invite/dZe3tqVTq4">
        <i /> Join Community
      </a>
    </div>

    {/* HERO VISUAL */}

    <div>
      <img src="https://files.buildwithfern.com/https://fanvue-api.docs.buildwithfern.com/docs/dba571b590d45232e070b00c18206bb02ad2a8f38437107c0fe180d2ca3d90ee/assets/landing-page/hero-image.svg" alt="Code transforming into a rich app interface" />
    </div>
  </div>

  {/* MARKET OPPORTUNITY */}

  <div>
    <div>
      <h2>
        The Opportunity
      </h2>

      <p>
        Join the ecosystem powering the next generation of creators.
      </p>
    </div>

    <CardGroup cols={3}>
      <Card title="17M+ Active Users" icon="fa-solid fa-users">
        Build for a massive, high-intent audience ready to engage with your applications via the Fanvue platform.
      </Card>

      <Card title="250K+ Creators" icon="fa-solid fa-star">
        Infrastructure for professional agencies and independent creators at scale.
      </Card>

      <Card title="App Store Monetisation" icon="fa-solid fa-store">
        Publish apps to the Fanvue App Store and monetise through native discovery, installs and billing (coming soon)
      </Card>
    </CardGroup>
  </div>

  {/* USE CASES */}

  <div>
    <div>
      <h2>
        What You Can Build
      </h2>

      <p>
        From simple scripts to full-scale SaaS platforms.
      </p>
    </div>

    {/* ROW 1 */}

    <div>
      <div>
        <img src="https://files.buildwithfern.com/https://fanvue-api.docs.buildwithfern.com/docs/44ad70b6f50884e883a4bcc53a610f1f75bf0643f9da6faf33438dc65f83df20/assets/landing-page/ai-chat-interface.svg" alt="AI Chat Interface" />
      </div>

      <div>
        <div>
          <h3>
            Build autonomous agents
          </h3>

          <p>
            Connect LLMs (like Claude, OpenAI) to the Fanvue API to create agents that automatically engage fans, reply to messages, upsell content, and post on behalf of creators - 24/7.
          </p>
        </div>

        <div>
          ```typescript title="Webhook Handler"
          app.post('/webhook', async (req, res) => {
            const { type, data } = req.body;

            if (type === 'message.created') {
              const reply = await openai.chat.completions.create({
                model: 'gpt-4',
                messages: [{ role: 'user', content: data.text }]
              });

              await fanvue.messages.send({
                chatId: data.chatId,
                text: reply.choices[0].message.content
              });
            }

            res.status(200).send('OK');
          });
          ```
        </div>
      </div>
    </div>

    {/* ROW 2 */}

    <div>
      <div>
        <div>
          <h3>
            Turn agency workflows into custom CRMs
          </h3>

          <p>
            Build internal or commercial CRMs that automate and streamline creator and fan management for agencies, using Fanvue's APIs.
          </p>
        </div>

        <div>
          ```json title="GET /agency/creators"
          [
            { "id": "c_12345", "name": "Creator A", "earnings_24h": 1500.00 },
            { "id": "c_67890", "name": "Creator B", "earnings_24h": 3200.50 }
          ]
          ```
        </div>
      </div>

      <div>
        <img src="https://files.buildwithfern.com/https://fanvue-api.docs.buildwithfern.com/docs/fcd5a08f6796e3f3b80e6b8b398921b49d441262d30c19c3f8e6d9256ece06c4/assets/landing-page/agency-dashboard.svg" alt="Agency Dashboard" />
      </div>
    </div>

    {/* ROW 3 */}

    <div>
      <div>
        <img src="https://files.buildwithfern.com/https://fanvue-api.docs.buildwithfern.com/docs/a4119a3ea7b2d9649863b4dc51cc4fd5aa022df16b8b24b775edd47d0c45727f/assets/landing-page/workflow-graph.svg" alt="n8n Workflow" />
      </div>

      <div>
        <div>
          <h3>
            Orchestrate creator workflows with n8n & MCP
          </h3>

          <p>
            Use n8n and MCP to connect Fanvue events and automate workflows on new subscribers, messages, renewals and churn. Automatically update your CRM, schedule post and notify teams - without manual work.
          </p>
        </div>

        <div>
          <div>
            <div>
              <span>Webhook Latency</span>

               

              <span>~45ms</span>
            </div>

            <div>
              <span>Reliability</span>

               

              <span>99.99%</span>
            </div>

            <div>
              Supported: n8n, Zapier, Make
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  {/* DEVELOPER EXPERIENCE - CENTERED */}

  <div>
    <div>
      <h2>
        Developer Experience
      </h2>

      <p>
        Built by developers, for developers.
      </p>
    </div>

    <CardGroup cols={3}>
      <Card title="Secure by Design" icon="fa-solid fa-shield-halved">
        Enterprise-grade OAuth2 ensures you can build public-facing apps securely.
      </Card>

      <Card title="Event-Driven" icon="fa-solid fa-bolt">
        Robust webhooks keep your app in sync with every tip, message, and subscription.
      </Card>

      <Card title="Community Powered" icon="fa-solid fa-users">
        Direct access to the API team and fellow builders in our dedicated Discord.
      </Card>
    </CardGroup>
  </div>

  {/* BOTTOM CTA */}

  <div>
    <div>
      <h2>
        The economy is waiting. <br />
        <span>Start shipping.</span>
      </h2>

      <div>
        <a href="/docs/introduction/welcome">
          Get started <i />
        </a>
      </div>
    </div>

    {/* Bottom Glow */}
  </div>
</div>


# Welcome

# Welcome to the Fanvue API

The Fanvue API gives you direct access to your creator platform data and tools. Whether you're a content creator looking to build custom workflows or an agency managing multiple creators, our API helps you connect your existing tools and automate your processes.

## What can you build?

Think of the Fanvue API as a bridge between your creative work and the tools you already use. You can connect your CRM system to automatically sync subscriber data, build custom dashboards that show exactly the metrics you care about, or create scripts that handle routine tasks like sending welcome messages to new subscribers.

Many creators use our API to build automated engagement tools that help them stay connected with their audience without the manual work. Agency managers often integrate it with their existing systems to get a unified view across all the creators they manage.

## How it works

The API uses simple HTTP requests with OAuth 2.0 for secure authentication. Users authorize your application to access their data, and you receive time-limited access tokens to make API calls on their behalf. You can access user profiles, chat conversations, subscriber lists, and creator data through straightforward endpoints. Everything is designed to be secure and respect the permissions users grant to your application.

## Getting started

You'll need to create an OAuth application to begin. Start with our [OAuth 2.0 tutorial](/docs/authentication/quick-start) to learn how to set up authentication and get access tokens. Once you have that configured, you can start making requests to explore user data. If you're ready to build something specific, our [quickstart guide](/docs/introduction/quick-start) walks you through creating your first integration step by step.

The possibilities are entirely up to you and what would make your creator workflow more efficient.


# Quick Start

# Fanvue OAuth Quick Start (Next.js App Router)

In a few minutes you’ll have a working Next.js app where users can “Login with Fanvue” using OAuth. We’ll start from the official Fanvue App Starter and run locally with pnpm.

### What you’ll build

* **Secure OAuth login** with Fanvue
* **Session-backed** current-user page after sign-in
* **Production-ready** settings you can deploy anywhere

<Note>
  ##### Prerequisites

  * Node.js 18 or later
  * pnpm installed
  * Access to the Fanvue Developer area to create an app (Client ID/Secret)
</Note>

## 1) Bootstrap from the Fanvue App Starter

Use the template repository: [Fanvue App Starter](https://github.com/fanvue/fanvue-app-starter)

Pick one of these ways to start from the template:

1. **Use this template on GitHub**

   * Open: [Fanvue App Starter](https://github.com/fanvue/fanvue-app-starter)
   * Click "Use this template" → "Create a new repository"
   * Clone your new repository locally

2. **Scaffold via degit**

   ```bash
   pnpm dlx degit fanvue/fanvue-app-starter my-fanvue-app
   cd my-fanvue-app
   ```

3. **Clone and re-init**
   ```bash
   git clone https://github.com/fanvue/fanvue-app-starter.git my-fanvue-app
   cd my-fanvue-app
   rm -rf .git && git init
   ```

<Warning>
  Always use pnpm for install, dev, and build commands.
</Warning>

## 2) Set up local HTTPS proxy

OAuth requires HTTPS redirect URIs, even in local development. We'll use `mkcert` and `local-ssl-proxy` to enable HTTPS locally.

### Install mkcert

```bash
brew install mkcert
```

### Generate SSL certificates

Replace `my-fanvue-app` with your app name:

```bash
mkcert -install
mkcert my-fanvue-app.dev
```

This creates two files: `my-fanvue-app.dev.pem` and `my-fanvue-app.dev-key.pem`

### Update hosts file

```bash
echo "127.0.0.1 my-fanvue-app.dev" | sudo tee -a /etc/hosts
```

<Note>
  You'll run the proxy later after configuring environment variables. The proxy will forward HTTPS
  traffic from port 3001 to your Next.js dev server on port 3000.
</Note>

## 3) Create your Fanvue OAuth app

In the Fanvue Developer area, create a new App to obtain credentials:

* **Client ID** and **Client Secret**
* **Redirect URI**
  * Development: `https://my-fanvue-app.dev:3001/api/oauth/callback` (replace `my-fanvue-app` with your app name)
  * Production: `https://YOUR_DOMAIN/api/oauth/callback`
* **Scopes**
  * For the starter, use: `read:self`
  * The starter automatically includes required system scopes (`openid`, `offline_access`, `offline`) in addition to what you set in `OAUTH_SCOPES`

## 4) Configure environment variables

Create `.env.local` in the project root and set the following (replace `my-fanvue-app` with your app name):

```bash
OAUTH_CLIENT_ID=YOUR_CLIENT_ID
OAUTH_CLIENT_SECRET=YOUR_CLIENT_SECRET
OAUTH_SCOPES=read:self
OAUTH_REDIRECT_URI=https://my-fanvue-app.dev:3001/api/oauth/callback
SESSION_SECRET=use-a-random-16-char-secret
SESSION_COOKIE_NAME=fanvue_oauth

# Normally you do not need to change these:
OAUTH_ISSUER_BASE_URL=https://auth.fanvue.com
API_BASE_URL=https://api.fanvue.com
```

<Warning>
  * Never commit `.env.local` to version control - Ensure `OAUTH_SCOPES` exactly matches what you
    configured in the Fanvue developer UI
</Warning>

## 5) Install and run locally

First, install dependencies and start the Next.js dev server:

```bash
pnpm install
pnpm dev
```

In a **separate terminal**, start the local SSL proxy (replace `my-fanvue-app` with your app name):

```bash
npx local-ssl-proxy --source 3001 --target 3000 --cert ./my-fanvue-app.dev.pem --key ./my-fanvue-app.dev-key.pem
```

Visit `https://my-fanvue-app.dev:3001` (replace with your app name) and click "Login with Fanvue". After authorizing, you'll be redirected back and see your current user JSON rendered by the app.

## 6) How it works (at a glance)

* Next.js App Router with an OAuth callback at `/api/oauth/callback`
* Session cookie (`SESSION_COOKIE_NAME`) signed with `SESSION_SECRET`
* Server-side calls to `API_BASE_URL` using the authenticated session
* Local SSL proxy forwards HTTPS requests to the Next.js dev server

## 7) Production deployment

* Set the same environment variables in your hosting provider
* In the Fanvue developer UI, add the production Redirect URI: `https://YOUR_DOMAIN/api/oauth/callback`
* Build and run

```bash
pnpm install
pnpm build
pnpm start
```

### Recommended services

* Vercel for hosting
* Supabase if you also need a database

## Troubleshooting

* **Invalid redirect URI**: The value in the Fanvue developer UI must exactly match `OAUTH_REDIRECT_URI` (including the HTTPS protocol and port 3001)
* **Scope mismatch**: `OAUTH_SCOPES` must exactly match the scopes selected in the Fanvue developer UI (starter uses `read:self`)
* **Missing session secret**: Set `SESSION_SECRET` to a random string with at least 16 characters
* **Certificate errors in browser**: Run `mkcert -install` to install the local CA certificate
* **Cannot reach app at .dev domain**: Verify the hosts file entry with `cat /etc/hosts | grep my-fanvue-app.dev`
* **Proxy connection refused**: Ensure the Next.js dev server is running on port 3000 before starting the proxy
* **Port already in use**: If port 3000 or 3001 is in use, stop other services or use different ports (update proxy and redirect URI accordingly)
* **Blank page after login**: Open browser DevTools and your terminal; ensure all env vars are set, the proxy is running, and the callback route is reachable

## Where to customize in the starter

* UI and login experience: `src/app/page.tsx`
* OAuth callback and session handling: `src/app/api/oauth/callback/route.ts`
* API calls after login: server routes under `src/app/api/**` using the session’s access token

## Next steps

* Add additional scopes in both the Fanvue developer UI and `OAUTH_SCOPES`
* Call other endpoints (e.g., chats, followers) from your server routes
* Protect pages with middleware that checks the session

Resources:

* Fanvue App Starter: [github.com/fanvue/fanvue-app-starter](https://github.com/fanvue/fanvue-app-starter)


# Overview

# Authentication Overview

## Why Authentication Matters

When you use the Fanvue API, authentication is your digital key that unlocks access to our platform. Here's why it's essential:

**Identity Verification**\
Authentication confirms who you are, ensuring that only authorized applications and users can access creator content and platform features.

**Access Control**\
Different applications need different levels of access. Authentication ensures you only see and modify the data you're supposed to, protecting both creators and fans.

**Data Protection**\
Your authentication credentials act as a secure barrier, preventing unauthorized access to sensitive information like personal details, financial data, and private content.

**Usage Monitoring**\
Authentication helps us monitor API usage, prevent abuse, and ensure fair access to our services for all developers and creators.

## How Fanvue API Authentication Works

The Fanvue API uses **OAuth 2.0** for authentication - a simple, secure method that's perfect for server-to-server communication.


# Quick Start

# Quick Start

Choose the path that best fits your needs:

### Starting a New Application

**Recommended**: Use the [Fanvue App Starter Kit](https://github.com/fanvue/fanvue-app-starter)

Our starter kit provides:

* Pre-configured OAuth 2.0 flow with PKCE
* Secure token management
* Best practices built-in
* Next.js template ready to deploy

Simply clone the repository, add your OAuth credentials, and you're ready to build.

### Adding OAuth to an Existing Application

If you're integrating OAuth into an existing application, follow the implementation steps below. For detailed technical specifications and code examples, see our [OAuth 2.0 Implementation Guide](/advanced/o-auth-2-0-implementation-guide).

## Implementation Steps

Here's the high-level flow for implementing OAuth 2.0:

### 1. Generate PKCE Parameters

Create `code_verifier` and `code_challenge` cryptographically.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    import { randomBytes, createHash } from 'crypto';

    const codeVerifier = randomBytes(32).toString('base64url');
    const codeChallenge = createHash('sha256')
      .update(codeVerifier)
      .digest('base64url');
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import secrets
    import hashlib
    import base64

    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8').rstrip('=')
    code_challenge = base64.urlsafe_b64encode(
        hashlib.sha256(code_verifier.encode('utf-8')).digest()
    ).decode('utf-8').rstrip('=')
    ```
  </Tab>
</Tabs>

### 2. Store Code Verifier

Save `code_verifier` securely in your session/cookie.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    // Express
    req.session.codeVerifier = codeVerifier;

    // Next.js
    cookies().set('code_verifier', codeVerifier, { httpOnly: true, secure: true });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    # Flask
    session['code_verifier'] = code_verifier

    # FastAPI
    response.set_cookie('code_verifier', code_verifier, httponly=True, secure=True)
    ```
  </Tab>
</Tabs>

### 3. Authorization Request

Redirect users to Fanvue with `code_challenge` and `code_challenge_method=S256`.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const authUrl = new URL('https://auth.fanvue.com/oauth2/auth');
    authUrl.searchParams.set('client_id', process.env.CLIENT_ID);
    authUrl.searchParams.set('redirect_uri', process.env.REDIRECT_URI);
    authUrl.searchParams.set('response_type', 'code');
    authUrl.searchParams.set('scope', 'openid offline_access offline read:self');
    authUrl.searchParams.set('state', randomBytes(32).toString('hex'));
    authUrl.searchParams.set('code_challenge', codeChallenge);
    authUrl.searchParams.set('code_challenge_method', 'S256');

    res.redirect(authUrl.toString());
    ```
  </Tab>

  <Tab title="Python">
    ```python
    from urllib.parse import urlencode

    params = {
        'client_id': os.getenv('CLIENT_ID'),
        'redirect_uri': os.getenv('REDIRECT_URI'),
        'response_type': 'code',
        'scope': 'openid offline_access offline read:self',
        'state': secrets.token_hex(32),
        'code_challenge': code_challenge,
        'code_challenge_method': 'S256'
    }

    auth_url = f"https://auth.fanvue.com/oauth2/auth?{urlencode(params)}"
    return redirect(auth_url)
    ```
  </Tab>
</Tabs>

### 4. User Consent

User logs in to Fanvue and approves the requested permissions (handled by Fanvue).

### 5. Authorization Grant

Fanvue redirects back to your app with an authorization code (handled by Fanvue).

### 6. Token Exchange

Exchange the authorization code for tokens, including the original `code_verifier`.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const response = await fetch('https://auth.fanvue.com/oauth2/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        client_id: process.env.CLIENT_ID,
        client_secret: process.env.CLIENT_SECRET,
        code: authorizationCode,
        redirect_uri: process.env.REDIRECT_URI,
        code_verifier: codeVerifier,
      }),
    });

    const tokens = await response.json();
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import requests

    response = requests.post(
        'https://auth.fanvue.com/oauth2/token',
        data={
            'grant_type': 'authorization_code',
            'client_id': os.getenv('CLIENT_ID'),
            'client_secret': os.getenv('CLIENT_SECRET'),
            'code': authorization_code,
            'redirect_uri': os.getenv('REDIRECT_URI'),
            'code_verifier': code_verifier,
        },
        headers={'Content-Type': 'application/x-www-form-urlencoded'}
    )

    tokens = response.json()
    ```
  </Tab>
</Tabs>

### 7. API Access

Use the access token to make authenticated API requests.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const response = await fetch('https://api.fanvue.com/users/me', {
      headers: { 'Authorization': `Bearer ${tokens.access_token}` }
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    response = requests.get(
        'https://api.fanvue.com/users/me',
        headers={'Authorization': f'Bearer {tokens["access_token"]}'}
    )
    ```
  </Tab>
</Tabs>

### 8. Token Refresh

Use refresh tokens to get new access tokens when they expire.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const response = await fetch('https://auth.fanvue.com/oauth2/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        client_id: process.env.CLIENT_ID,
        client_secret: process.env.CLIENT_SECRET,
        refresh_token: tokens.refresh_token,
      }),
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python
    response = requests.post(
        'https://auth.fanvue.com/oauth2/token',
        data={
            'grant_type': 'refresh_token',
            'client_id': os.getenv('CLIENT_ID'),
            'client_secret': os.getenv('CLIENT_SECRET'),
            'refresh_token': tokens['refresh_token'],
        }
    )
    ```
  </Tab>
</Tabs>

<Info>
  **PKCE (Proof Key for Code Exchange) is required** for all OAuth 2.0 flows. It's a security extension that prevents authorization code interception attacks. See the [Implementation Guide](/advanced/o-auth-2-0-implementation-guide#pkce-proof-key-for-code-exchange) for detailed PKCE implementation instructions and complete examples.
</Info>

## Next Steps

### Ready to Build?

* **New Project**: Clone the [Fanvue App Starter Kit](https://github.com/fanvue/fanvue-app-starter) and follow the README
* **Complete Tutorial**: See our [Quickstart Guide](/introduction/quick-start) for a step-by-step walkthrough
* **Technical Details**: Review the [OAuth 2.0 Implementation Guide](./oauth-advanced) for PKCE implementation, token exchange specs, and troubleshooting

### Need Help?

* **App Management**: Visit the [developer portal](https://fanvue.com/developers/apps) to manage your OAuth applications
* **API Reference**: Check our [API documentation](https://api.fanvue.com/docs) for endpoint details
* **Starter Template**: Explore the [Fanvue App Starter Kit](https://github.com/fanvue/fanvue-app-starter) source code


# Implementation Guide

# Implementation Guide

This guide provides comprehensive technical details for implementing OAuth 2.0 with the Fanvue API. If you're looking for a quick start, see the [OAuth 2.0 Tutorial](./quick-start).

## OAuth 2.0 Flow Diagram

```mermaid
sequenceDiagram
    participant User
    participant YourApp as Your Application
    participant Fanvue as Fanvue Authorization Server
    participant API as Fanvue API

    User->>YourApp: 1. Initiates login/connection
    YourApp->>YourApp: 2. Generates code_verifier & code_challenge
    YourApp->>User: 3. Redirects to Fanvue authorization URL (with code_challenge)
    User->>Fanvue: 4. Logs in and grants permissions
    Fanvue->>YourApp: 5. Redirects back with authorization code
    YourApp->>Fanvue: 6. Exchanges code for access token (with code_verifier)
    Fanvue->>Fanvue: 7. Verifies code_verifier matches code_challenge
    Fanvue->>YourApp: 8. Returns access token & refresh token
    YourApp->>API: 9. Makes API calls with access token
    API->>YourApp: 10. Returns requested data
```

## PKCE (Proof Key for Code Exchange)

**PKCE is required for all OAuth 2.0 flows.** It's a security extension that prevents authorization code interception attacks.

### How PKCE Works

1. **Generate a Code Verifier**: Create a cryptographically random string (43-128 characters)
2. **Create a Code Challenge**: Hash the verifier using SHA-256 and encode it as Base64URL
3. **Send Challenge with Authorization**: Include `code_challenge` in the authorization request
4. **Store Verifier Securely**: Keep the `code_verifier` in your application (see storage options below)
5. **Send Verifier with Token Exchange**: Include `code_verifier` when exchanging the authorization code
6. **Server Verification**: Fanvue verifies that `SHA256(code_verifier)` matches the original `code_challenge`

This ensures that even if an attacker intercepts the authorization code, they cannot exchange it for tokens without the original `code_verifier`.

### Storing the Code Verifier

You must securely store the `code_verifier` between the authorization request and token exchange:

**Recommended Options:**

* **Server-side session storage** (preferred): Store in Redis, database, or in-memory session
* **Secure HTTP-only cookies**: Use `Secure`, `HttpOnly`, and `SameSite=Lax` flags
* **Encrypted client storage**: Only if server-side storage isn't possible

⚠️ **Never** store the verifier in:

* Local storage or session storage (vulnerable to XSS)
* URL parameters
* Client-side JavaScript variables that persist across page loads

### Code Examples

<Tabs>
  <Tab title="JavaScript/Node.js">
    ```javascript
    import { randomBytes, createHash } from 'crypto';

    // Generate code verifier (43-128 characters)
    function generateCodeVerifier() {
      return base64URLEncode(randomBytes(32));
    }

    // Generate code challenge from verifier
    function generateCodeChallenge(verifier) {
      return base64URLEncode(
        createHash('sha256').update(verifier).digest()
      );
    }

    // Helper function for Base64URL encoding
    function base64URLEncode(buffer) {
      return buffer
        .toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
    }

    // Usage
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);

    // Store codeVerifier in session/cookie for later use
    // Send codeChallenge with authorization request
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import secrets
    import hashlib
    import base64

    def generate_code_verifier():
        """Generate a code verifier (43-128 characters)"""
        code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8')
        return code_verifier.rstrip('=')

    def generate_code_challenge(verifier):
        """Generate code challenge from verifier using SHA-256"""
        digest = hashlib.sha256(verifier.encode('utf-8')).digest()
        challenge = base64.urlsafe_b64encode(digest).decode('utf-8')
        return challenge.rstrip('=')

    # Usage
    code_verifier = generate_code_verifier()
    code_challenge = generate_code_challenge(code_verifier)

    # Store code_verifier in session for later use
    # Send code_challenge with authorization request
    ```
  </Tab>

  <Tab title="Other Languages">
    For any programming language, follow these steps:

    1. **Generate code\_verifier**:
       * Create 32 random bytes
       * Encode as Base64URL (Base64 with `+` → `-`, `/` → `_`, remove `=` padding)
       * Result should be 43 characters minimum

    2. **Generate code\_challenge**:
       * Hash the `code_verifier` using SHA-256
       * Encode the hash as Base64URL
       * Set `code_challenge_method=S256`

    3. **Base64URL Encoding**:
       * Standard Base64 encoding
       * Replace `+` with `-`
       * Replace `/` with `_`
       * Remove trailing `=` padding characters
  </Tab>
</Tabs>

## Authorization URL Format

<Info>
  You should always include these default scopes:

  * `openid` - Required for OpenID Connect; enables ID token generation and access to user identity
  * `offline_access` - Provides refresh tokens so your app can obtain new access tokens without re-authentication
  * `offline` - Enables long-term access for background operations
</Info>

**Required Parameters:**

* `client_id` - Your OAuth application's client ID
* `redirect_uri` - Where users are redirected after authorization (must match your app configuration)
* `response_type=code` - Indicates authorization code flow
* `scope` - Space-separated list of permissions (URL encoded with `+`)
* `state` - Random string to prevent CSRF attacks (verify this matches on callback)
* `code_challenge` - **\[PKCE Required]** The Base64URL-encoded SHA-256 hash of your `code_verifier`
* `code_challenge_method=S256` - **\[PKCE Required]** Indicates SHA-256 hashing method

```
https://auth.fanvue.com/oauth2/auth?
  client_id=YOUR_CLIENT_ID&
  redirect_uri=YOUR_REDIRECT_URI&
  response_type=code&
  scope=openid+offline_access+offline+read:self+read:chat&
  state=RANDOM_STRING&
  code_challenge=CODE_CHALLENGE&
  code_challenge_method=S256
```

## Token Exchange

After receiving the authorization code, exchange it for access and refresh tokens.

**Required Parameters:**

* `grant_type=authorization_code` - Indicates you're exchanging an authorization code
* `client_id` - Your OAuth application's client ID
* `client_secret` - Your OAuth application's client secret
* `code` - The authorization code received from the callback
* `redirect_uri` - Must match the redirect URI used in the authorization request
* `code_verifier` - **\[PKCE Required]** The original `code_verifier` you generated (NOT the challenge)

⚠️ **Important**: Send the `code_verifier`, not the `code_challenge`. The server will hash the verifier and compare it to the challenge you sent earlier.

```http
POST https://auth.fanvue.com/oauth2/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
client_id=YOUR_CLIENT_ID&
client_secret=YOUR_CLIENT_SECRET&
code=AUTHORIZATION_CODE&
redirect_uri=YOUR_REDIRECT_URI&
code_verifier=CODE_VERIFIER
```

**Response:**

```json
{
  "access_token": "eyJhbGc...",
  "refresh_token": "eyJhbGc...",
  "id_token": "eyJhbGc...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "openid offline_access offline read:self read:chat"
}
```

## Handling the OAuth Callback

After the user authorizes your application, Fanvue redirects them back to your specified `redirect_uri` with the authorization code and state parameter.

### Callback URL Format

```
https://your-app.com/callback?code=AUTHORIZATION_CODE&state=STATE_VALUE
```

### Implementation Examples

<Tabs>
  <Tab title="Express.js">
    ```javascript
    import express from 'express';
    import { randomBytes } from 'crypto';

    const app = express();

    // Step 1: Initiate OAuth flow
    app.get('/auth/fanvue', (req, res) => {
      const codeVerifier = generateCodeVerifier();
      const codeChallenge = generateCodeChallenge(codeVerifier);
      const state = randomBytes(32).toString('hex');

      // Store code_verifier and state in session
      req.session.codeVerifier = codeVerifier;
      req.session.oauthState = state;

      const authUrl = new URL('https://auth.fanvue.com/oauth2/auth');
      authUrl.searchParams.append('client_id', process.env.CLIENT_ID);
      authUrl.searchParams.append('redirect_uri', process.env.REDIRECT_URI);
      authUrl.searchParams.append('response_type', 'code');
      authUrl.searchParams.append('scope', 'openid offline_access offline read:self');
      authUrl.searchParams.append('state', state);
      authUrl.searchParams.append('code_challenge', codeChallenge);
      authUrl.searchParams.append('code_challenge_method', 'S256');

      res.redirect(authUrl.toString());
    });

    // Step 2: Handle OAuth callback
    app.get('/callback', async (req, res) => {
      const { code, state } = req.query;

      // Validate state parameter (CSRF protection)
      if (!state || state !== req.session.oauthState) {
        return res.status(400).send('Invalid state parameter');
      }

      // Retrieve the stored code_verifier
      const codeVerifier = req.session.codeVerifier;
      if (!codeVerifier) {
        return res.status(400).send('Code verifier not found in session');
      }

      // Clear session data
      delete req.session.oauthState;
      delete req.session.codeVerifier;

      try {
        // Exchange authorization code for tokens
        const tokenResponse = await fetch('https://auth.fanvue.com/oauth2/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            client_id: process.env.CLIENT_ID,
            client_secret: process.env.CLIENT_SECRET,
            code: code,
            redirect_uri: process.env.REDIRECT_URI,
            code_verifier: codeVerifier,
          }),
        });

        if (!tokenResponse.ok) {
          const error = await tokenResponse.json();
          throw new Error(`Token exchange failed: ${error.error_description}`);
        }

        const tokens = await tokenResponse.json();

        // Store tokens securely (e.g., encrypted in database)
        req.session.accessToken = tokens.access_token;
        req.session.refreshToken = tokens.refresh_token;
        req.session.tokenExpiry = Date.now() + (tokens.expires_in * 1000);

        res.redirect('/dashboard');
      } catch (error) {
        console.error('OAuth callback error:', error);
        res.status(500).send('Authentication failed');
      }
    });
    ```
  </Tab>

  <Tab title="Next.js (App Router)">
    ```typescript
    // app/auth/fanvue/route.ts
    import { NextRequest, NextResponse } from 'next/server';
    import { cookies } from 'next/headers';
    import { generateCodeVerifier, generateCodeChallenge } from '@/lib/pkce';

    export async function GET(request: NextRequest) {
      const codeVerifier = generateCodeVerifier();
      const codeChallenge = generateCodeChallenge(codeVerifier);
      const state = crypto.randomUUID();

      // Store in HTTP-only cookies
      cookies().set('oauth_code_verifier', codeVerifier, {
        httpOnly: true,
        secure: true,
        sameSite: 'lax',
        maxAge: 600, // 10 minutes
      });

      cookies().set('oauth_state', state, {
        httpOnly: true,
        secure: true,
        sameSite: 'lax',
        maxAge: 600,
      });

      const authUrl = new URL('https://auth.fanvue.com/oauth2/auth');
      authUrl.searchParams.append('client_id', process.env.CLIENT_ID!);
      authUrl.searchParams.append('redirect_uri', process.env.REDIRECT_URI!);
      authUrl.searchParams.append('response_type', 'code');
      authUrl.searchParams.append('scope', 'openid offline_access offline read:self');
      authUrl.searchParams.append('state', state);
      authUrl.searchParams.append('code_challenge', codeChallenge);
      authUrl.searchParams.append('code_challenge_method', 'S256');

      return NextResponse.redirect(authUrl);
    }

    // app/callback/route.ts
    import { NextRequest, NextResponse } from 'next/server';
    import { cookies } from 'next/headers';

    export async function GET(request: NextRequest) {
      const searchParams = request.nextUrl.searchParams;
      const code = searchParams.get('code');
      const state = searchParams.get('state');

      // Retrieve stored values from cookies
      const storedState = cookies().get('oauth_state')?.value;
      const codeVerifier = cookies().get('oauth_code_verifier')?.value;

      // Validate state parameter
      if (!state || state !== storedState) {
        return NextResponse.json(
          { error: 'Invalid state parameter' },
          { status: 400 }
        );
      }

      if (!codeVerifier) {
        return NextResponse.json(
          { error: 'Code verifier not found' },
          { status: 400 }
        );
      }

      // Clear cookies
      cookies().delete('oauth_state');
      cookies().delete('oauth_code_verifier');

      try {
        // Exchange code for tokens
        const tokenResponse = await fetch('https://auth.fanvue.com/oauth2/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            client_id: process.env.CLIENT_ID!,
            client_secret: process.env.CLIENT_SECRET!,
            code: code!,
            redirect_uri: process.env.REDIRECT_URI!,
            code_verifier: codeVerifier,
          }),
        });

        if (!tokenResponse.ok) {
          const error = await tokenResponse.json();
          throw new Error(error.error_description || 'Token exchange failed');
        }

        const tokens = await tokenResponse.json();

        // Store tokens securely (e.g., in database or encrypted session)
        // For demo purposes, storing in cookies (in production, use a database)
        cookies().set('access_token', tokens.access_token, {
          httpOnly: true,
          secure: true,
          sameSite: 'lax',
          maxAge: tokens.expires_in,
        });

        cookies().set('refresh_token', tokens.refresh_token, {
          httpOnly: true,
          secure: true,
          sameSite: 'lax',
          maxAge: 60 * 60 * 24 * 30, // 30 days
        });

        return NextResponse.redirect(new URL('/dashboard', request.url));
      } catch (error) {
        console.error('OAuth callback error:', error);
        return NextResponse.json(
          { error: 'Authentication failed' },
          { status: 500 }
        );
      }
    }
    ```
  </Tab>

  <Tab title="Flask">
    ```python
    from flask import Flask, session, redirect, request, url_for
    import requests
    import secrets
    from lib.pkce import generate_code_verifier, generate_code_challenge

    app = Flask(__name__)
    app.secret_key = 'your-secret-key-here'  # Use a secure secret key

    # Step 1: Initiate OAuth flow
    @app.route('/auth/fanvue')
    def auth_fanvue():
        # Generate PKCE parameters
        code_verifier = generate_code_verifier()
        code_challenge = generate_code_challenge(code_verifier)
        state = secrets.token_hex(32)

        # Store code_verifier and state in session
        session['code_verifier'] = code_verifier
        session['oauth_state'] = state

        # Build authorization URL
        params = {
            'client_id': os.getenv('CLIENT_ID'),
            'redirect_uri': os.getenv('REDIRECT_URI'),
            'response_type': 'code',
            'scope': 'openid offline_access offline read:self',
            'state': state,
            'code_challenge': code_challenge,
            'code_challenge_method': 'S256'
        }

        auth_url = 'https://auth.fanvue.com/oauth2/auth'
        query_string = '&'.join([f'{k}={v}' for k, v in params.items()])

        return redirect(f'{auth_url}?{query_string}')

    # Step 2: Handle OAuth callback
    @app.route('/callback')
    def callback():
        code = request.args.get('code')
        state = request.args.get('state')

        # Validate state parameter (CSRF protection)
        if not state or state != session.get('oauth_state'):
            return 'Invalid state parameter', 400

        # Retrieve the stored code_verifier
        code_verifier = session.get('code_verifier')
        if not code_verifier:
            return 'Code verifier not found in session', 400

        # Clear session data
        session.pop('oauth_state', None)
        session.pop('code_verifier', None)

        try:
            # Exchange authorization code for tokens
            token_response = requests.post(
                'https://auth.fanvue.com/oauth2/token',
                data={
                    'grant_type': 'authorization_code',
                    'client_id': os.getenv('CLIENT_ID'),
                    'client_secret': os.getenv('CLIENT_SECRET'),
                    'code': code,
                    'redirect_uri': os.getenv('REDIRECT_URI'),
                    'code_verifier': code_verifier,
                },
                headers={'Content-Type': 'application/x-www-form-urlencoded'}
            )

            if not token_response.ok:
                error = token_response.json()
                raise Exception(f"Token exchange failed: {error.get('error_description')}")

            tokens = token_response.json()

            # Store tokens securely (e.g., encrypted in database)
            session['access_token'] = tokens['access_token']
            session['refresh_token'] = tokens['refresh_token']
            session['token_expiry'] = time.time() + tokens['expires_in']

            return redirect('/dashboard')
        except Exception as error:
            print(f'OAuth callback error: {error}')
            return 'Authentication failed', 500

    if __name__ == '__main__':
        app.run()
    ```
  </Tab>

  <Tab title="FastAPI">
    ```python
    from fastapi import FastAPI, Request, HTTPException, Response
    from fastapi.responses import RedirectResponse
    import httpx
    import secrets
    from typing import Optional
    import os
    from lib.pkce import generate_code_verifier, generate_code_challenge

    app = FastAPI()

    # In-memory session store (use Redis or database in production)
    sessions = {}

    def get_session_id(request: Request) -> str:
        """Get or create session ID from cookie"""
        session_id = request.cookies.get('session_id')
        if not session_id:
            session_id = secrets.token_hex(32)
        return session_id

    def get_session(session_id: str) -> dict:
        """Get session data"""
        if session_id not in sessions:
            sessions[session_id] = {}
        return sessions[session_id]

    # Step 1: Initiate OAuth flow
    @app.get('/auth/fanvue')
    async def auth_fanvue(request: Request):
        session_id = get_session_id(request)
        session = get_session(session_id)

        # Generate PKCE parameters
        code_verifier = generate_code_verifier()
        code_challenge = generate_code_challenge(code_verifier)
        state = secrets.token_hex(32)

        # Store code_verifier and state in session
        session['code_verifier'] = code_verifier
        session['oauth_state'] = state

        # Build authorization URL
        params = {
            'client_id': os.getenv('CLIENT_ID'),
            'redirect_uri': os.getenv('REDIRECT_URI'),
            'response_type': 'code',
            'scope': 'openid offline_access offline read:self',
            'state': state,
            'code_challenge': code_challenge,
            'code_challenge_method': 'S256'
        }

        auth_url = 'https://auth.fanvue.com/oauth2/auth'
        query_string = '&'.join([f'{k}={v}' for k, v in params.items()])

        response = RedirectResponse(url=f'{auth_url}?{query_string}')
        response.set_cookie(
            key='session_id',
            value=session_id,
            httponly=True,
            secure=True,
            samesite='lax',
            max_age=600  # 10 minutes
        )

        return response

    # Step 2: Handle OAuth callback
    @app.get('/callback')
    async def callback(
        request: Request,
        code: Optional[str] = None,
        state: Optional[str] = None
    ):
        session_id = request.cookies.get('session_id')
        if not session_id:
            raise HTTPException(status_code=400, detail='Session not found')

        session = get_session(session_id)

        # Validate state parameter (CSRF protection)
        if not state or state != session.get('oauth_state'):
            raise HTTPException(status_code=400, detail='Invalid state parameter')

        # Retrieve the stored code_verifier
        code_verifier = session.get('code_verifier')
        if not code_verifier:
            raise HTTPException(status_code=400, detail='Code verifier not found in session')

        # Clear session data
        session.pop('oauth_state', None)
        session.pop('code_verifier', None)

        try:
            # Exchange authorization code for tokens
            async with httpx.AsyncClient() as client:
                token_response = await client.post(
                    'https://auth.fanvue.com/oauth2/token',
                    data={
                        'grant_type': 'authorization_code',
                        'client_id': os.getenv('CLIENT_ID'),
                        'client_secret': os.getenv('CLIENT_SECRET'),
                        'code': code,
                        'redirect_uri': os.getenv('REDIRECT_URI'),
                        'code_verifier': code_verifier,
                    },
                    headers={'Content-Type': 'application/x-www-form-urlencoded'}
                )

                if token_response.status_code != 200:
                    error = token_response.json()
                    raise Exception(f"Token exchange failed: {error.get('error_description')}")

                tokens = token_response.json()

                # Store tokens securely (e.g., encrypted in database)
                session['access_token'] = tokens['access_token']
                session['refresh_token'] = tokens['refresh_token']
                session['token_expiry'] = httpx.get_time() + tokens['expires_in']

                return RedirectResponse(url='/dashboard')
        except Exception as error:
            print(f'OAuth callback error: {error}')
            raise HTTPException(status_code=500, detail='Authentication failed')
    ```
  </Tab>
</Tabs>

### Key Implementation Points

1. **State Validation**: Always validate the `state` parameter to prevent CSRF attacks
2. **Retrieve Code Verifier**: Get the stored `code_verifier` from session/cookies
3. **Error Handling**: Handle missing parameters and failed token exchanges gracefully
4. **Clean Up**: Remove temporary session data after successful exchange
5. **Secure Storage**: Store tokens securely (encrypted database preferred over sessions)

## Token Refresh Flow

Access tokens expire after a short period (typically 1 hour). Use refresh tokens to obtain new access tokens without requiring users to re-authenticate.

### Refresh Token Request

```http
POST https://auth.fanvue.com/oauth2/token
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&
client_id=YOUR_CLIENT_ID&
client_secret=YOUR_CLIENT_SECRET&
refresh_token=YOUR_REFRESH_TOKEN
```

**Response:**

```json
{
  "access_token": "eyJhbGc...",
  "refresh_token": "eyJhbGc...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "openid offline_access offline read:self read:chat"
}
```

### Automatic Token Refresh Implementation

<Tabs>
  <Tab title="JavaScript/Node.js">
    ```javascript
    class FanvueClient {
      constructor(accessToken, refreshToken, expiresAt) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
        this.tokenExpiresAt = expiresAt;
        this.refreshPromise = null;
      }

      async ensureValidToken() {
        // Check if token is expired or about to expire (within 5 minutes)
        const now = Date.now();
        const bufferTime = 5 * 60 * 1000; // 5 minutes

        if (now + bufferTime >= this.tokenExpiresAt) {
          // If already refreshing, wait for that promise
          if (this.refreshPromise) {
            return this.refreshPromise;
          }

          // Start refresh process
          this.refreshPromise = this.refreshAccessToken();

          try {
            await this.refreshPromise;
          } finally {
            this.refreshPromise = null;
          }
        }

        return this.accessToken;
      }

      async refreshAccessToken() {
        try {
          const response = await fetch('https://auth.fanvue.com/oauth2/token', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
              grant_type: 'refresh_token',
              client_id: process.env.CLIENT_ID,
              client_secret: process.env.CLIENT_SECRET,
              refresh_token: this.refreshToken,
            }),
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(`Token refresh failed: ${error.error_description}`);
          }

          const tokens = await response.json();

          // Update tokens
          this.accessToken = tokens.access_token;
          this.refreshToken = tokens.refresh_token;
          this.tokenExpiresAt = Date.now() + (tokens.expires_in * 1000);

          // Save updated tokens to storage (database, session, etc.)
          await this.saveTokens();

          return this.accessToken;
        } catch (error) {
          console.error('Token refresh error:', error);
          throw error;
        }
      }

      async makeApiRequest(endpoint, options = {}) {
        // Ensure we have a valid token
        const token = await this.ensureValidToken();

        const response = await fetch(`https://api.fanvue.com${endpoint}`, {
          ...options,
          headers: {
            ...options.headers,
            'Authorization': `Bearer ${token}`,
          },
        });

        // Handle token expiration during request
        if (response.status === 401) {
          // Token might have expired, try refreshing and retry once
          await this.refreshAccessToken();
          const token = this.accessToken;

          return fetch(`https://api.fanvue.com${endpoint}`, {
            ...options,
            headers: {
              ...options.headers,
              'Authorization': `Bearer ${token}`,
            },
          });
        }

        return response;
      }

      async saveTokens() {
        // Implement your storage logic here
        // Example: save to database, update session, etc.
      }
    }

    // Usage
    const client = new FanvueClient(accessToken, refreshToken, expiresAt);
    const response = await client.makeApiRequest('/users/me');
    const user = await response.json();
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import time
    import requests
    from datetime import datetime, timedelta
    from threading import Lock

    class FanvueClient:
        def __init__(self, access_token, refresh_token, expires_at):
            self.access_token = access_token
            self.refresh_token = refresh_token
            self.token_expires_at = expires_at
            self.refresh_lock = Lock()
            self.client_id = os.getenv('CLIENT_ID')
            self.client_secret = os.getenv('CLIENT_SECRET')

        def ensure_valid_token(self):
            """Ensure we have a valid access token, refreshing if necessary"""
            now = time.time()
            buffer_time = 5 * 60  # 5 minutes

            if now + buffer_time >= self.token_expires_at:
                with self.refresh_lock:
                    # Double-check after acquiring lock
                    if now + buffer_time >= self.token_expires_at:
                        self.refresh_access_token()

            return self.access_token

        def refresh_access_token(self):
            """Refresh the access token using the refresh token"""
            try:
                response = requests.post(
                    'https://auth.fanvue.com/oauth2/token',
                    data={
                        'grant_type': 'refresh_token',
                        'client_id': self.client_id,
                        'client_secret': self.client_secret,
                        'refresh_token': self.refresh_token,
                    },
                    headers={'Content-Type': 'application/x-www-form-urlencoded'}
                )

                response.raise_for_status()
                tokens = response.json()

                # Update tokens
                self.access_token = tokens['access_token']
                self.refresh_token = tokens['refresh_token']
                self.token_expires_at = time.time() + tokens['expires_in']

                # Save updated tokens to storage
                self.save_tokens()

                return self.access_token
            except requests.exceptions.RequestException as e:
                print(f'Token refresh error: {e}')
                raise

        def make_api_request(self, endpoint, method='GET', **kwargs):
            """Make an API request with automatic token refresh"""
            # Ensure valid token
            token = self.ensure_valid_token()

            headers = kwargs.pop('headers', {})
            headers['Authorization'] = f'Bearer {token}'

            response = requests.request(
                method,
                f'https://api.fanvue.com{endpoint}',
                headers=headers,
                **kwargs
            )

            # Handle token expiration during request
            if response.status_code == 401:
                # Try refreshing and retry once
                self.refresh_access_token()
                headers['Authorization'] = f'Bearer {self.access_token}'

                response = requests.request(
                    method,
                    f'https://api.fanvue.com{endpoint}',
                    headers=headers,
                    **kwargs
                )

            return response

        def save_tokens(self):
            """Save tokens to storage (implement based on your storage solution)"""
            # Example: save to database, update session, etc.
            pass

    # Usage
    client = FanvueClient(access_token, refresh_token, expires_at)
    response = client.make_api_request('/users/me')
    user = response.json()
    ```
  </Tab>
</Tabs>

### Token Refresh Best Practices

1. **Proactive Refresh**: Refresh tokens before they expire (5-10 minutes buffer)
2. **Handle Concurrent Requests**: Use locks/promises to prevent multiple simultaneous refresh attempts
3. **Retry Logic**: If a request fails with 401, try refreshing the token once and retry
4. **Secure Storage**: Store refresh tokens securely and encrypted
5. **Update Both Tokens**: The refresh response may include a new refresh token - always update both
6. **Error Handling**: If refresh fails, redirect user to re-authenticate

## Best Practices

### Security

* **PKCE is mandatory** - Always implement PKCE for all OAuth flows (see PKCE section above)
* **Code Verifier Requirements**:
  * Minimum 43 characters, maximum 128 characters
  * Use cryptographically secure random generation
  * Store securely server-side (session/Redis preferred) or in HTTP-only cookies
  * Never expose in URLs, local storage, or client-side JavaScript
* Always use HTTPS in production
* Store tokens securely (encrypted at rest)
* Implement proper token refresh logic
* Use the `state` parameter to prevent CSRF attacks (minimum 32 random characters)
* Validate redirect URIs match exactly what's configured in your app
* Keep your Client Secret secure and never expose it in client-side code

### User Experience

* Clearly explain what permissions your app needs
* Handle authorization errors gracefully
* Provide a way for users to disconnect your app
* Respect rate limits and user privacy

### Token Management

* Access tokens are short-lived (typically 1 hour)
* Use refresh tokens to get new access tokens
* Handle token expiration gracefully
* Revoke tokens when users disconnect
* Implement automatic token refresh before expiration

## Troubleshooting

### Common Errors

This section provides code examples for handling common OAuth errors.

#### Invalid Client ID

**Error Response:**

```json
{
  "error": "invalid_client",
  "error_description": "Client authentication failed"
}
```

**Solutions:**

* Verify your Client ID is correct
* Ensure the app is active in your developer dashboard

#### Redirect URI Mismatch

**Error Response:**

```json
{
  "error": "invalid_request",
  "error_description": "The redirect_uri does not match the registered callback URL"
}
```

**Solutions:**

* Check that the redirect URI matches exactly what's configured
* Ensure the URI is properly URL-encoded
* Verify protocol (http vs https) matches exactly

#### Invalid Scope

**Error Response:**

```json
{
  "error": "invalid_scope",
  "error_description": "The requested scope is invalid or not available"
}
```

**Solutions:**

* Verify the requested scopes are available and properly formatted
* Check that your app has been granted the necessary permissions
* Ensure scopes are space-separated and URL-encoded with `+`

#### Token Expired

**Error Response:**

```json
{
  "error": "invalid_grant",
  "error_description": "Token has expired"
}
```

**Solutions:**

* Implement automatic token refresh (see Token Refresh Flow section)
* Handle 401 responses by refreshing tokens

#### PKCE Validation Failed

**Error Response:**

```json
{
  "error": "invalid_grant",
  "error_description": "Code verifier does not match code challenge"
}
```

**Solutions:**

* Ensure you're sending the original `code_verifier`, not the `code_challenge`
* Verify the code verifier is stored and retrieved correctly
* Check that the same verifier used to generate the challenge is sent in token exchange

### Error Handling Implementation

<Tabs>
  <Tab title="JavaScript/Node.js">
    ```javascript
    class OAuthError extends Error {
      constructor(error, errorDescription, statusCode) {
        super(errorDescription || error);
        this.name = 'OAuthError';
        this.error = error;
        this.errorDescription = errorDescription;
        this.statusCode = statusCode;
      }
    }

    async function handleOAuthRequest(url, options) {
      try {
        const response = await fetch(url, options);

        // Handle HTTP errors
        if (!response.ok) {
          const contentType = response.headers.get('content-type');

          if (contentType && contentType.includes('application/json')) {
            const errorData = await response.json();
            throw new OAuthError(
              errorData.error || 'unknown_error',
              errorData.error_description || 'An unknown error occurred',
              response.status
            );
          }

          throw new OAuthError(
            'http_error',
            `HTTP ${response.status}: ${response.statusText}`,
            response.status
          );
        }

        return await response.json();
      } catch (error) {
        if (error instanceof OAuthError) {
          throw error;
        }

        // Handle network errors
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          throw new OAuthError(
            'network_error',
            'Network request failed. Please check your connection.',
            0
          );
        }

        throw error;
      }
    }

    // Usage with specific error handling
    async function exchangeCodeForTokens(code, codeVerifier) {
      try {
        const tokens = await handleOAuthRequest(
          'https://auth.fanvue.com/oauth2/token',
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
              grant_type: 'authorization_code',
              client_id: process.env.CLIENT_ID,
              client_secret: process.env.CLIENT_SECRET,
              code: code,
              redirect_uri: process.env.REDIRECT_URI,
              code_verifier: codeVerifier,
            }),
          }
        );

        return tokens;
      } catch (error) {
        if (error instanceof OAuthError) {
          // Handle specific OAuth errors
          switch (error.error) {
            case 'invalid_client':
              console.error('Invalid client credentials. Check CLIENT_ID and CLIENT_SECRET.');
              break;
            case 'invalid_grant':
              if (error.errorDescription.includes('code verifier')) {
                console.error('PKCE validation failed. Check code_verifier matches code_challenge.');
              } else if (error.errorDescription.includes('expired')) {
                console.error('Authorization code expired. User needs to re-authenticate.');
              }
              break;
            case 'invalid_request':
              if (error.errorDescription.includes('redirect_uri')) {
                console.error('Redirect URI mismatch. Check your app configuration.');
              }
              break;
            default:
              console.error(`OAuth error: ${error.error} - ${error.errorDescription}`);
          }
        }

        throw error;
      }
    }

    // Retry logic with exponential backoff
    async function makeApiRequestWithRetry(endpoint, options = {}, maxRetries = 3) {
      let lastError;

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const response = await fetch(`https://api.fanvue.com${endpoint}`, options);

          if (response.status === 429) {
            // Rate limit hit
            const retryAfter = response.headers.get('Retry-After');
            const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000;

            console.log(`Rate limited. Retrying after ${waitTime}ms...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue;
          }

          if (response.status >= 500) {
            // Server error - retry with exponential backoff
            if (attempt < maxRetries - 1) {
              const waitTime = Math.pow(2, attempt) * 1000;
              console.log(`Server error. Retrying after ${waitTime}ms...`);
              await new Promise(resolve => setTimeout(resolve, waitTime));
              continue;
            }
          }

          if (!response.ok) {
            const error = await response.json();
            throw new Error(`API error: ${error.message || response.statusText}`);
          }

          return await response.json();
        } catch (error) {
          lastError = error;

          // Don't retry on client errors (4xx except 429)
          if (error.statusCode >= 400 && error.statusCode < 500 && error.statusCode !== 429) {
            throw error;
          }

          // If this is the last attempt, throw
          if (attempt === maxRetries - 1) {
            throw error;
          }
        }
      }

      throw lastError;
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import time
    import requests
    from typing import Dict, Any, Optional

    class OAuthError(Exception):
        def __init__(self, error: str, error_description: str, status_code: int):
            self.error = error
            self.error_description = error_description
            self.status_code = status_code
            super().__init__(error_description or error)

    def handle_oauth_request(url: str, **kwargs) -> Dict[str, Any]:
        """Make an OAuth request with proper error handling"""
        try:
            response = requests.request('POST', url, **kwargs)

            # Handle HTTP errors
            if not response.ok:
                content_type = response.headers.get('Content-Type', '')

                if 'application/json' in content_type:
                    error_data = response.json()
                    raise OAuthError(
                        error_data.get('error', 'unknown_error'),
                        error_data.get('error_description', 'An unknown error occurred'),
                        response.status_code
                    )

                raise OAuthError(
                    'http_error',
                    f'HTTP {response.status_code}: {response.reason}',
                    response.status_code
                )

            return response.json()
        except requests.exceptions.ConnectionError:
            raise OAuthError(
                'network_error',
                'Network request failed. Please check your connection.',
                0
            )
        except requests.exceptions.Timeout:
            raise OAuthError(
                'timeout_error',
                'Request timed out. Please try again.',
                0
            )

    def exchange_code_for_tokens(code: str, code_verifier: str) -> Dict[str, Any]:
        """Exchange authorization code for tokens with error handling"""
        try:
            tokens = handle_oauth_request(
                'https://auth.fanvue.com/oauth2/token',
                data={
                    'grant_type': 'authorization_code',
                    'client_id': os.getenv('CLIENT_ID'),
                    'client_secret': os.getenv('CLIENT_SECRET'),
                    'code': code,
                    'redirect_uri': os.getenv('REDIRECT_URI'),
                    'code_verifier': code_verifier,
                },
                headers={'Content-Type': 'application/x-www-form-urlencoded'}
            )

            return tokens
        except OAuthError as error:
            # Handle specific OAuth errors
            if error.error == 'invalid_client':
                print('Invalid client credentials. Check CLIENT_ID and CLIENT_SECRET.')
            elif error.error == 'invalid_grant':
                if 'code verifier' in error.error_description:
                    print('PKCE validation failed. Check code_verifier matches code_challenge.')
                elif 'expired' in error.error_description:
                    print('Authorization code expired. User needs to re-authenticate.')
            elif error.error == 'invalid_request':
                if 'redirect_uri' in error.error_description:
                    print('Redirect URI mismatch. Check your app configuration.')
            else:
                print(f'OAuth error: {error.error} - {error.error_description}')

            raise

    def make_api_request_with_retry(
        endpoint: str,
        method: str = 'GET',
        max_retries: int = 3,
        **kwargs
    ) -> Dict[str, Any]:
        """Make API request with retry logic and exponential backoff"""
        last_error = None

        for attempt in range(max_retries):
            try:
                response = requests.request(
                    method,
                    f'https://api.fanvue.com{endpoint}',
                    **kwargs
                )

                if response.status_code == 429:
                    # Rate limit hit
                    retry_after = response.headers.get('Retry-After')
                    wait_time = int(retry_after) if retry_after else 2 ** attempt

                    print(f'Rate limited. Retrying after {wait_time}s...')
                    time.sleep(wait_time)
                    continue

                if response.status_code >= 500:
                    # Server error - retry with exponential backoff
                    if attempt < max_retries - 1:
                        wait_time = 2 ** attempt
                        print(f'Server error. Retrying after {wait_time}s...')
                        time.sleep(wait_time)
                        continue

                response.raise_for_status()
                return response.json()

            except requests.exceptions.RequestException as error:
                last_error = error

                # Don't retry on client errors (4xx except 429)
                if hasattr(error, 'response') and error.response is not None:
                    status = error.response.status_code
                    if 400 <= status < 500 and status != 429:
                        raise

                # If this is the last attempt, raise
                if attempt == max_retries - 1:
                    raise

        raise last_error

    # Usage
    try:
        tokens = exchange_code_for_tokens(auth_code, code_verifier)
        print('Successfully obtained tokens')
    except OAuthError as e:
        print(f'OAuth failed: {e.error_description}')
    ```
  </Tab>
</Tabs>

### Best Practices for Error Handling

1. **Distinguish Error Types**: Separate OAuth errors, network errors, and application errors
2. **Provide Context**: Log enough information to debug issues without exposing secrets
3. **Retry Strategically**: Retry on server errors (5xx) and rate limits (429), not client errors (4xx)
4. **Exponential Backoff**: Wait longer between each retry attempt
5. **User-Friendly Messages**: Show helpful error messages to users, not raw error codes
6. **Monitor Errors**: Track error rates to identify systemic issues

## Support

For additional help with OAuth 2.0 integration:

* **Quick Start**: See the [OAuth 2.0 Tutorial](./oauth-tutorial) for a getting started guide
* **Implementation**: Follow our [Quickstart Guide](/introduction/quick-start) for a complete Next.js example
* **API Reference**: Check our [API documentation](https://api.fanvue.com/docs)
* **App Management**: Visit the [developer portal](https://fanvue.com/developers/apps)
* **Template**: Review the [starter template](https://github.com/fanvue/fanvue-app-starter) on GitHub


# Scopes

# Scopes

## What are Scopes?

Scopes are like permissions that control what your app can do when users connect it to their Fanvue account using OAuth 2.0. Think of them as specific access levels that determine which resources your application can read from or write to.

When you create your OAuth app, you'll specify which scopes you need based on what your app does. This ensures your application only has access to the data and features it actually needs, following the principle of least privilege for better security.

To learn more about OAuth 2.0 and how to set up your app, check out our [OAuth Tutorial](./o-auth-2-0).

## How Scopes Work

* **Permission Control**: Each scope grants access to specific resources and actions
* **Request Validation**: Every API request checks if your access token has the required scopes
* **Error Handling**: Requests without sufficient scopes return a `403 Forbidden` error
* **App Configuration**: Scopes are set when you create your OAuth app and determine what permissions users can grant

## Available Scopes

The following table lists all available scopes organized by resource:

| Resource | Scopes                          |
| -------- | ------------------------------- |
| User     | `read:self`                     |
| Chat     | `read:chat`, `write:chat`       |
| Fan      | `read:fan`                      |
| Creator  | `read:creator`, `write:creator` |
| Media    | `read:media`, `write:media`     |
| Posts    | `write:post`                    |
| Insights | `read:insights`                 |

### Scope Descriptions

**`read:self`**\
Access your own user profile information, including basic account details and settings.

**`read:chat`**\
Read chat conversations, messages, and chat-related data. This includes viewing chat lists and message history.

**`write:chat`**\
Create new chats and send messages. This scope is required for any chat-related actions that modify data.

**`read:fan`**\
Access fan-related data and information within the platform.

**`read:creator`**
Access creator profiles, content, and creator-specific information.

**`write:creator`**
Modify creator profiles, settings, and creator-specific data.

**`read:media`**
Access media files, images, videos, and other content assets.

**`write:media`**
Upload, modify, and manage media files and content assets.

**`write:post`**
Create, edit, and manage posts and content on behalf of users.

**`read:insights`**
Access analytics, metrics, and insights data for performance tracking.

## Setting Up Scopes

When creating your OAuth app, you'll configure which scopes your app can request:

1. **Choose the scopes** your app actually needs
2. **Follow the principle of least privilege** - only request what's necessary
3. **Consider your users** - they'll see what permissions you're asking for

Users will then grant (or deny) these specific permissions when they connect your app to their account. For the complete setup process, see our [OAuth Tutorial](./o-auth-2-0).

## Error Handling

If your access token doesn't have the required scopes for a request, you'll receive:

```json
{
  "error": "Insufficient scopes"
}
```

This response comes with a `403 Forbidden` HTTP status code. Make sure your app requests all necessary scopes and that users have granted them.


# Rate Limits

# Rate Limits

Rate limits are like traffic lights for API requests - they keep our servers running smoothly, ensure fair access for everyone, prevent abuse, and maintain reliable service quality.

## Current Limits

By default, each user can make **100 requests per 60 seconds**. This means you get 100 tokens in your bucket, and it refills completely every minute.

## Dive deeper

If you want to learn more about rate limits, how it's implemented and how to work with them, you can read all about it in our [Advanced Rate Limits Guide](/docs/advanced/working-with-rate-limits).


# Working With Rate Limits

# Working With Rate Limits

A rate limit is like having a bucket with a limited number of tokens. Each API request uses one token from your bucket. The bucket refills with new tokens over time, but if you use all your tokens, you'll need to wait for more to be added before making additional requests.

## How Rate Limits Work

Think of rate limiting like a water faucet with a flow regulator:

1. **Token Bucket**: You start with a full bucket of 100 request tokens
2. **Request Consumption**: Each API call uses one token from your bucket
3. **Bucket Refill**: Your bucket refills completely every 60 seconds
4. **Overflow Protection**: If your bucket is empty, you must wait for it to refill before making more requests

The system tracks your usage in real-time and provides information about your current status through response headers.

## Rate Limit Tracking

Rate limits work differently depending on your authentication method:

### OAuth 2.0 (Recommended)

When using OAuth 2.0 with Bearer tokens, rate limits are tracked **per-user**. Each user who authorizes your application gets their own separate rate limit bucket. This means:

* User A's API usage doesn't affect User B's limits
* Multiple applications using the same user's token share that user's rate limit
* This provides fair usage distribution across all users

## Tracking Your Usage

Every API response includes headers that tell you about your current rate limit status:

### Response Headers

**`X-RateLimit-Limit`**\
The total number of requests allowed in the current time window.

```
X-RateLimit-Limit: 100
```

**`X-RateLimit-Remaining`**\
The number of requests you have left in the current time window.

```
X-RateLimit-Remaining: 75
```

**`X-RateLimit-Reset`**\
A Unix timestamp indicating when your rate limit will reset (when your bucket refills).

```
X-RateLimit-Reset: 1672531200
```

**`Retry-After` (when rate limited)**\
When you exceed your rate limit, this header tells you how many seconds to wait before trying again.

```
Retry-After: 30
```

### Example Response Headers

Here's what you might see in a successful response:

```http
HTTP/1.1 200 OK
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 45
X-RateLimit-Reset: 1672531200
Content-Type: application/json

{
  "uuid": "123e4567-e89b-12d3-a456-426614174000",
  "email": "user@example.com"
}
```

## When You Exceed Rate Limits

If you make too many requests and exceed your rate limit, you'll receive a `429 Too Many Requests` response:

```http
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1672531200
Retry-After: 45
Content-Type: application/json

{
  "error": "Too many requests"
}
```

This response tells you:

* You've used all 100 of your allowed requests
* You have 0 requests remaining
* Your limit will reset at timestamp 1672531200
* You should wait 45 seconds before making another request

## Working with Rate Limits In Your App

### Handle Rate Limit Errors

Implement proper error handling for rate limit responses:

```javascript
async function makeAPIRequest(url, accessToken) {
  const response = await fetch(url, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });

  if (response.status === 429) {
    const retryAfter = response.headers.get("Retry-After");
    console.log(`Rate limited. Retry after ${retryAfter} seconds`);

    // Wait and retry
    await new Promise((resolve) => setTimeout(resolve, retryAfter * 1000));
    return makeAPIRequest(url, accessToken);
  }

  return response.json();
}
```

### Best Practices

**Implement Exponential Backoff**\
When you hit rate limits, wait progressively longer between retry attempts.

**Batch Your Requests**\
If possible, combine multiple operations into fewer API calls.

**Cache Responses**\
Store API responses locally to reduce the number of requests you need to make.

**Monitor Continuously**\
Keep track of your rate limit headers to avoid hitting limits unexpectedly.

**Plan for Peak Usage**\
Consider your application's peak usage patterns and design accordingly.

### Python Example

```python
import requests
import time

def make_request_with_retry(url, access_token, max_retries=3):
    headers = {
        'Authorization': f'Bearer {access_token}'
    }

    for attempt in range(max_retries + 1):
        response = requests.get(url, headers=headers)

        # Check rate limit headers
        remaining = int(response.headers.get('X-RateLimit-Remaining', 0))
        print(f"Requests remaining: {remaining}")

        if response.status_code == 429:
            if attempt < max_retries:
                retry_after = int(response.headers.get('Retry-After', 60))
                print(f"Rate limited. Waiting {retry_after} seconds...")
                time.sleep(retry_after)
                continue
            else:
                raise Exception("Max retries exceeded")

        return response.json()
```


# Overview

# API Versioning

API versioning ensures backward compatibility and allows us to introduce improvements without breaking existing integrations.

The current version of the Fanvue API is `2025-06-26`.

## Version Header

All API requests must include the `X-Fanvue-API-Version` header to specify which version of the API you want to use.

```bash
curl -H "X-Fanvue-API-Version: 2025-06-26" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  https://api.fanvue.com/users/me
```

## Error Responses

**400 Bad Request** - When requesting an unsupported version:

```json
{
  "error": "Unsupported API version",
  "message": "API version '2024-01-01' is not supported"
}
```

**410 Gone** - When requesting a sunset (removed) version:

```json
{
  "error": "API version no longer supported",
  "message": "API version '2024-01-01' was sunset on 2024-12-31T00:00:00.000Z",
  "nextVersion": "2025-06-26"
}
```

## Dive deeper

For advanced version management strategies, migration patterns, and production best practices, check out our [Version Management Strategies](/docs/advanced/version-management-strategies).


# Management Strategies

# Management Strategies

API versioning is like having different editions of a software library. Each version represents a snapshot of the API at a specific point in time, with its own set of features, bug fixes, and behaviors. Unlike traditional software where you choose which version to install, with APIs you specify which "edition" you want to use with each request.

## How API Versioning Works

Think of API versioning like a library with multiple editions of the same book:

1. **Version Selection**: You specify which edition (version) you want to read with each request
2. **Compatibility**: Each version maintains its behavior, even as newer versions are released
3. **Deprecation**: Older editions eventually go out of print (get deprecated)
4. **Sunset**: Eventually, very old editions are removed from the library entirely

The API uses your version header to determine which set of behaviors, response formats, and business logic to apply to your request.

## Version Lifecycle Management

Every API version goes through a predictable lifecycle:

* **Active**: Current version, fully supported with new features
* **Deprecated**: Still works but marked for future removal
* **Sunset**: No longer available, returns 410 Gone

## Understanding Deprecation Headers

When you use a deprecated API version, the response includes detailed information about the deprecation timeline:

### Response Headers

**`Deprecation`**\
RFC 8594 standard header indicating when the version was officially deprecated.

```
Deprecation: Wed, 11 Nov 2024 23:59:59 GMT
```

**`Sunset`**\
RFC 8594 standard header indicating when the version will stop working.

```
Sunset: Wed, 11 Nov 2025 23:59:59 GMT
```

**`X-Fanvue-API-Next-Version`**\
Fanvue-specific header recommending which version to migrate to.

```
X-Fanvue-API-Next-Version: 2025-06-26
```

### Example Response with Deprecation

Here's what you'll see when using a deprecated version:

```http
HTTP/1.1 200 OK
Deprecation: Wed, 11 Nov 2024 23:59:59 GMT
Sunset: Wed, 11 Nov 2025 23:59:59 GMT
X-Fanvue-API-Next-Version: 2025-06-26
Content-Type: application/json

{
  "uuid": "123e4567-e89b-12d3-a456-426614174000",
  "email": "user@example.com",
  "handle": "creator123"
}
```

This response tells you:

* The version was deprecated on November 11, 2024
* It will stop working on November 11, 2025
* You should migrate to version 2025-06-26
* Your request still works for now

## Version Error Responses

### Unsupported Version (400)

When you request a version that was never supported:

```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "Unsupported API version",
  "message": "API version '2024-01-01' is not supported"
}
```

### Sunset Version (410)

When you request a version that has been permanently removed:

```http
HTTP/1.1 410 Gone
Content-Type: application/json

{
  "error": "API version no longer supported",
  "message": "API version '2024-01-01' was sunset on 2024-12-31T00:00:00.000Z",
  "nextVersion": "2025-06-26"
}
```

## Building Version-Aware Applications

### Version Header Management

Always include the version header in your API client configuration:

```javascript
class FanvueAPIClient {
  constructor(accessToken, version) {
    this.accessToken = accessToken;
    this.version = version;
    this.baseURL = "https://api.fanvue.com";
  }

  async request(endpoint, options = {}) {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      ...options,
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "X-Fanvue-API-Version": this.version,
        "Content-Type": "application/json",
        ...options.headers,
      },
    });

    // Check for deprecation warnings
    this.handleDeprecationHeaders(response);

    return this.handleResponse(response);
  }

  handleDeprecationHeaders(response) {
    const deprecation = response.headers.get("Deprecation");
    const sunset = response.headers.get("Sunset");
    const nextVersion = response.headers.get("X-Fanvue-API-Next-Version");

    if (deprecation) {
      console.warn(`API version ${this.version} is deprecated as of ${deprecation}`);
      if (sunset) {
        console.warn(`Version will stop working on ${sunset}`);
      }
      if (nextVersion) {
        console.warn(`Consider upgrading to version ${nextVersion}`);
      }
    }
  }
}
```

### Version Error Handling

Implement robust error handling for version-related failures:

```javascript
async function handleResponse(response) {
  if (response.status === 400) {
    const error = await response.json();
    if (error.error === "Unsupported API version") {
      throw new UnsupportedVersionError(error.message);
    }
  }

  if (response.status === 410) {
    const error = await response.json();
    if (error.error === "API version no longer supported") {
      throw new SunsetVersionError(error.message, error.nextVersion);
    }
  }

  if (!response.ok) {
    throw new APIError(`HTTP ${response.status}: ${response.statusText}`);
  }

  return response.json();
}

class UnsupportedVersionError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnsupportedVersionError";
  }
}

class SunsetVersionError extends Error {
  constructor(message, nextVersion) {
    super(message);
    this.name = "SunsetVersionError";
    this.nextVersion = nextVersion;
  }
}
```

### Python Implementation

```python
import requests
import logging
from datetime import datetime
from typing import Optional

class FanvueClient:
    def __init__(self, access_token: str, version: str):
        self.access_token = access_token
        self.version = version
        self.base_url = "https://api.fanvue.com"
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {access_token}',
            'X-Fanvue-API-Version': version,
            'Content-Type': 'application/json'
        })

    def request(self, method: str, endpoint: str, **kwargs):
        response = self.session.request(method, f"{self.base_url}{endpoint}", **kwargs)

        # Monitor deprecation status
        self._check_deprecation_headers(response)

        # Handle version errors
        if response.status_code == 400:
            error_data = response.json()
            if "Unsupported API version" in error_data.get("error", ""):
                raise UnsupportedVersionError(error_data["message"])

        if response.status_code == 410:
            error_data = response.json()
            if "API version no longer supported" in error_data.get("error", ""):
                raise SunsetVersionError(
                    error_data["message"],
                    error_data.get("nextVersion")
                )

        response.raise_for_status()
        return response.json()

    def _check_deprecation_headers(self, response):
        deprecation = response.headers.get('Deprecation')
        sunset = response.headers.get('Sunset')
        next_version = response.headers.get('X-Fanvue-API-Next-Version')

        if deprecation:
            logging.warning(f"API version {self.version} deprecated as of {deprecation}")
            if sunset:
                sunset_date = datetime.strptime(sunset, '%a, %d %b %Y %H:%M:%S %Z')
                logging.warning(f"Version sunset scheduled for {sunset_date}")
            if next_version:
                logging.warning(f"Recommended migration to version {next_version}")

class UnsupportedVersionError(Exception):
    pass

class SunsetVersionError(Exception):
    def __init__(self, message: str, next_version: Optional[str] = None):
        super().__init__(message)
        self.next_version = next_version
```

## Advanced Version Management Strategies

### Version Pinning

Pin to specific versions in production to ensure predictable behavior:

```javascript
// Good: Explicit version pinning
const client = new FanvueAPIClient(accessToken, "2025-06-26");

// Avoid: Dynamic version selection in production
const client = new FanvueAPIClient(accessToken, getLatestVersion());
```

### Graceful Migration Patterns

Implement gradual migration with fallback logic:

```javascript
class VersionMigrationClient extends FanvueAPIClient {
  constructor(accessToken, primaryVersion, fallbackVersion) {
    super(accessToken, primaryVersion);
    this.fallbackVersion = fallbackVersion;
  }

  async requestWithFallback(endpoint, options = {}) {
    try {
      return await this.request(endpoint, options);
    } catch (error) {
      if (error instanceof SunsetVersionError) {
        console.warn(`Primary version sunset, falling back to ${this.fallbackVersion}`);
        // Create temporary client with fallback version
        const fallbackClient = new FanvueAPIClient(this.accessToken, this.fallbackVersion);
        return await fallbackClient.request(endpoint, options);
      }
      throw error;
    }
  }
}
```

### Monitoring and Alerting

Set up monitoring for deprecation warnings:

```javascript
class MonitoredAPIClient extends FanvueAPIClient {
  constructor(accessToken, version, metricsCollector) {
    super(accessToken, version);
    this.metrics = metricsCollector;
  }

  handleDeprecationHeaders(response) {
    const deprecation = response.headers.get("Deprecation");
    const sunset = response.headers.get("Sunset");

    if (deprecation) {
      this.metrics.increment("api.version.deprecated", {
        version: this.version,
        deprecation_date: deprecation,
        sunset_date: sunset,
      });

      // Alert if sunset is approaching
      if (sunset) {
        const sunsetDate = new Date(sunset);
        const daysUntilSunset = (sunsetDate - new Date()) / (1000 * 60 * 60 * 24);

        if (daysUntilSunset <= 30) {
          this.metrics.alert("api.version.sunset_approaching", {
            version: this.version,
            days_remaining: Math.floor(daysUntilSunset),
          });
        }
      }
    }
  }
}
```

## Best Practices for Production

### Configuration Management

* Store API versions in environment variables or configuration files
* Use the same version across all environments (dev, staging, production)
* Document which version each deployment uses

### Testing Strategy

* Test version migration in staging environments first
* Implement integration tests for each supported API version
* Validate that deprecated versions still work as expected

### Deployment Planning

* Plan version migrations during maintenance windows
* Implement feature flags for gradual version rollouts
* Monitor error rates closely after version changes

### Team Coordination

* Establish clear policies for when to upgrade API versions
* Create alerts for deprecation warnings in production
* Document migration procedures for your team


# Docs For Your LLM

# Docs for LLMs

Our API documentation is available in text formats optimized for Large Language Models.

## Endpoints

**Standard:** [http://api.fanvue.com/docs/llms.txt](http://api.fanvue.com/docs/llms.txt)

**Full:** [http://api.fanvue.com/docs/llms-full.txt](http://api.fanvue.com/docs/llms-full.txt)

Use these URLs to provide your LLM with current API information.


# Example Chatbots

# Example Chatbots

To help you get started with the Fanvue API, we provide example chatbot applications that demonstrate how to integrate with our API using OAuth 2.0 authentication. These examples are available for both Python (Flask) and JavaScript (Node.js/Express).

You can find the full source code and setup instructions on GitHub:

**[Fanvue Chatbot Examples on GitHub](https://github.com/fanvue/fanvue-chatbot-example)**

## Features

Both examples include:

* **OAuth 2.0 Authentication**: Securely connect to the Fanvue API.
* **Chat Interface**: A simple web-based UI for interacting with the chatbot.
* **API Integration**: Demonstrates sending and receiving messages via the Fanvue API.
* **Comprehensive Setup**: Includes detailed instructions for getting started.

These examples are a great starting point for building your own custom chatbot or integrating Fanvue's chat functionality into your existing applications.


# Multipart Media Upload

# Building a Photo Vault with Multipart Upload

Learn how to create a complete photo vault interface that displays existing user images and enables reliable large file uploads using advanced multipart upload techniques.

This comprehensive tutorial teaches both the concepts and implementation details, providing a complete working example that demonstrates best practices for handling file uploads in production applications.

## Understanding Multipart Upload

### What is Multipart Upload?

Imagine you need to mail a 500-page book to someone, but the postal service only accepts packages up to 50 pages. You could:

1. **Regular approach**: Try to force the entire book into one package (fails)
2. **Multipart approach**: Split the book into 10 packages of 50 pages each, mail them separately, then have the recipient reassemble them

Multipart upload works the same way with files. Instead of sending one massive HTTP request with your entire file, you:

1. **Split** the file into smaller chunks (typically 5-10MB each)
2. **Upload** each chunk independently using signed URLs
3. **Combine** the chunks server-side into the original file

### Why Use Multipart Upload?

**🚀 Performance Benefits**

* Chunks upload in parallel, utilizing full bandwidth
* Faster overall upload times for large files
* Better resource utilization

**🔄 Reliability Improvements**

* If one chunk fails, only that chunk needs retry (not the entire file)
* Network interruptions don't restart the entire upload
* Automatic retry logic for transient failures

**📊 Better User Experience**

* Granular progress tracking (chunk-by-chunk)
* Users can see exactly how much has uploaded
* Cancel/resume functionality

**🏗️ Technical Advantages**

* No single request size limits (overcome HTTP timeouts)
* Reduced server memory usage (chunks processed individually)
* Improved error isolation and debugging

### When Should You Use Multipart Upload?

**✅ Use multipart upload when:**

* Files are larger than 10MB
* Users are on unreliable connections (mobile networks)
* You need detailed progress feedback
* Building production applications with user-generated content
* Handling media files (images, videos, audio)

**❌ Regular upload is fine when:**

* Files are small (\< 5MB)
* Network is reliable and fast
* Simple use cases without progress requirements
* Prototypes or internal tools

### How Multipart Upload Works (The 3-Phase Flow)

Understanding this flow is crucial for implementing multipart upload correctly:

```mermaid
sequenceDiagram
    participant Client
    participant API
    participant Storage

    Note over Client,Storage: Phase 1: Create Upload Session
    Client->>API: POST /media/uploads
    API->>Storage: Create multipart upload
    Storage-->>API: Upload ID
    API-->>Client: Media UUID + Upload ID

    Note over Client,Storage: Phase 2: Upload Parts
    loop For each chunk
        Client->>API: GET /media/uploads/{uploadId}/parts/{partNumber}/url
        API-->>Client: Signed URL
        Client->>Storage: PUT chunk to signed URL
        Storage-->>Client: ETag for chunk
    end

    Note over Client,Storage: Phase 3: Complete Upload Session
    Client->>API: PATCH /media/uploads/{uploadId}
    API->>Storage: Complete multipart upload
    Storage-->>API: Final file URL
    API-->>Client: Processing started
```

**Phase 1: Create Upload Session (Setup)**

* Tell the server you want to upload a file
* Server creates a media record in database
* Server starts a multipart upload session
* You receive a `mediaUuid` and `uploadId` for tracking

**Phase 2: Upload Parts (The Heavy Lifting)**

* Split your file into chunks (we'll use 10MB chunks)
* For each chunk:
  * Request a signed URL for that specific part number
  * Upload the chunk directly to cloud storage using the signed URL
  * Save the ETag returned by storage (proof of successful upload)

**Phase 3: Complete Upload Session (Assembly)**

* Tell the server all chunks are uploaded
* Provide the list of ETags to prove which chunks were uploaded
* Server combines chunks into the final file
* File enters processing pipeline (thumbnail generation, etc.)

## What You'll Build

By the end of this tutorial, you'll have a complete photo vault featuring:

**📱 Photo Grid Interface**

* Responsive grid that adapts to screen size
* Displays existing vault images using optimized thumbnails
* Infinite scroll pagination for large image collections
* Loading states and graceful error handling

**⬆️ Advanced Upload System**

* Multipart upload with 10MB chunking
* Real-time progress tracking with visual feedback
* Automatic retry logic for failed chunks
* Upload queue management (multiple files simultaneously)
* File validation and error handling

**🛡️ Production-Ready Features**

* OAuth authentication integration
* Proper error boundaries and user feedback
* Mobile-responsive design
* Security best practices
* Performance optimizations

## Learning Objectives

After completing this tutorial, you'll understand:

* How multipart upload works under the hood
* When and why to use multipart vs regular uploads
* How to implement chunked file upload with progress tracking
* OAuth authentication patterns for API access
* React patterns for handling async file operations
* Error handling strategies for network operations
* Performance optimization techniques for file uploads

<Note>
  #### Before You Start

  **Complete the [Quickstart Guide](/docs/introduction/quick-start) first** to set up OAuth authentication, environment variables, and your basic Fanvue app. This tutorial builds on that foundation and focuses specifically on multipart upload implementation.
</Note>

## Prerequisites

Since you've completed the [Quickstart Guide](/docs/introduction/quick-start), you should have:

* ✅ A working Next.js app with Fanvue OAuth authentication
* ✅ Environment variables configured (`OAUTH_CLIENT_ID`, `OAUTH_CLIENT_SECRET`, etc.)
* ✅ Basic `read:self` scope working for user authentication

### Additional Scopes Required

Add these scopes to your existing `OAUTH_SCOPES` in `.env.local`:

```env
# Add these to your existing OAuth scopes from the quickstart
OAUTH_SCOPES=read:self read:media write:media
```

<Note>
  Make sure to update your app configuration in the Fanvue Developer area to include the
  `read:media` and `write:media` scopes.
</Note>

### Technical Requirements

* **File API Knowledge**: Understanding of JavaScript File objects and Blob handling
* **React Patterns**: Experience with hooks, async state management, and component patterns

Ready to dive in? Let's start by understanding how to fetch and display existing vault images, then build up to the complete multipart upload system.

## Step 1: Fetch Existing Vault Images

Before we dive into multipart uploads, let's start with something simpler: displaying existing images in the user's vault. This will help us understand the API structure and build the foundation for our upload system.

### Understanding the Media API

The Fanvue API organizes user content into **media items** with different **variants** (sizes/formats). For our vault, we'll focus on:

* **Media Type**: `image` (filtering out videos and audio)
* **Variant Type**: `thumbnail_gallery` (optimized for grid display)

### Building the API Client

Our API client handles OAuth authentication and provides methods for media operations. Notice how we use **Bearer token authentication**:

```typescript
// lib/fanvue-api.ts
// Enhanced Fanvue API client with OAuth authentication

const API_BASE = "https://api.fanvue.com";

export interface MediaItem {
  uuid: string;
  status: "created" | "processing" | "ready" | "error";
  createdAt?: string;
  url?: string;
  caption?: string | null;
  description?: string | null;
  name?: string | null;
  variants?: Array<{
    uuid: string;
    variantType: "blurred" | "main" | "thumbnail" | "thumbnail_gallery";
    displayPosition: number;
    url?: string;
    width: number | null;
    height: number | null;
    lengthMs: number | null;
  }>;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    size: number;
    hasMore: boolean;
  };
}

export class FanvueAPI {
  private accessToken: string;
  private baseURL: string;

  // 🔑 OAuth access token for authenticated requests
  constructor(accessToken: string) {
    this.accessToken = accessToken;
    this.baseURL = API_BASE;
  }

  // 🛠️ Private helper method for making authenticated requests
  private async makeRequest(endpoint: string, options: RequestInit = {}): Promise<Response> {
    const url = `${this.baseURL}${endpoint}`;

    const response = await fetch(url, {
      ...options,
      headers: {
        // 🔐 OAuth Bearer token authentication
        Authorization: `Bearer ${this.accessToken}`,
        "X-Fanvue-API-Version": "2025-06-26",
        "Content-Type": "application/json",
        ...options.headers,
      },
      cache: "no-store", // Fresh data for user's vault
    });

    if (!response.ok) {
      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
      try {
        const errorBody = await response.json();
        errorMessage = errorBody.message || errorBody.error || errorMessage;
      } catch {
        // If we can't parse the error body, use the original message
      }
      throw new Error(errorMessage);
    }

    return response;
  }

  // 📸 Get user's media with flexible filtering options
  async getUserMedia(
    options: {
      mediaType?: "image" | "video" | "audio";
      variants?: Array<"blurred" | "main" | "thumbnail" | "thumbnail_gallery">;
      status?: Array<"created" | "processing" | "ready" | "error">;
      page?: number;
      size?: number;
    } = {}
  ): Promise<PaginatedResponse<MediaItem>> {
    // Build query parameters - the API uses URL parameters for filtering
    const params = new URLSearchParams();

    if (options.mediaType) params.set("mediaType", options.mediaType);
    if (options.variants?.length) params.set("variants", options.variants.join(","));
    if (options.status?.length) params.set("status", options.status.join(","));
    if (options.page) params.set("page", options.page.toString());
    if (options.size) params.set("size", options.size.toString());

    const response = await this.makeRequest(`/media?${params}`);
    return response.json();
  }
}
```

**What's happening here:**

1. **OAuth Authentication**: We use `Authorization: Bearer ${token}`
2. **Error Handling**: Structured error parsing with fallbacks
3. **Flexibility**: Support for filtering by type, status, variants, and pagination
4. **Type Safety**: Full TypeScript interfaces for all API responses

### Building the Photo Grid Component

Now let's create a React component that displays user images in a responsive grid. This component demonstrates pagination, loading states, and error handling patterns you'll use throughout the vault.

```typescript
'use client';

// components/PhotoGrid.tsx
import { useState, useEffect, useCallback } from 'react';
import { FanvueAPI, MediaItem } from '../lib/fanvue-api';

interface PhotoGridProps {
  accessToken: string; // 🔑 OAuth access token
  onImageClick?: (item: MediaItem) => void;
  refreshTrigger?: number; // Used to refresh when new images are uploaded
}

export function PhotoGrid({ accessToken, onImageClick, refreshTrigger }: PhotoGridProps) {
  const [images, setImages] = useState<MediaItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);

  // 🏗️ Create API client with OAuth token
  const api = new FanvueAPI(accessToken);

  const loadImages = useCallback(async (pageNum: number = 1, reset: boolean = false) => {
    try {
      if (pageNum === 1) {
        setLoading(true);
      } else {
        setLoadingMore(true);
      }

      // 📡 Fetch user's images with specific filtering
      const response = await api.getUserMedia({
        mediaType: 'image',          // Only images, not videos
        variants: ['thumbnail_gallery'], // Optimized thumbnails for grid display
        status: ['ready'],           // Only fully processed images
        page: pageNum,
        size: 20,                    // 20 images per page
      });

      // 🔍 Double-check that images have thumbnails (defensive programming)
      const vaultImages = response.data.filter((item: MediaItem) => {
        const hasThumbnail = item.variants?.some(v =>
          v.variantType === 'thumbnail_gallery' && v.url
        );
        return item.status === 'ready' && hasThumbnail;
      });

      setImages(prev => reset ? vaultImages : [...prev, ...vaultImages]);
      setHasMore(response.pagination.hasMore);
      setError(null);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load images';
      setError(errorMessage);
      console.error('Error loading images:', err);
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  }, [api]);

  // 🚀 Load initial images when component mounts or token changes
  useEffect(() => {
    if (accessToken) {
      loadImages(1, true);
      setPage(1);
    }
  }, [accessToken, loadImages]);

  // 🔄 Reload when refreshTrigger changes (after uploads complete)
  useEffect(() => {
    if (refreshTrigger && refreshTrigger > 0) {
      loadImages(1, true);
      setPage(1);
    }
  }, [refreshTrigger, loadImages]);

  const loadMore = useCallback(() => {
    if (!loadingMore && hasMore && !loading) {
      const nextPage = page + 1;
      setPage(nextPage);
      loadImages(nextPage, false);
    }
  }, [loadingMore, hasMore, loading, page, loadImages]);

  // 🎨 Loading state for initial load
  if (loading && images.length === 0) {
    return (
      <div className="flex items-center justify-center p-12">
        <div className="text-center">
          <div className="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-4"></div>
          <p className="text-gray-600">Loading your vault...</p>
        </div>
      </div>
    );
  }

  // ❌ Error state with retry option
  if (error && images.length === 0) {
    return (
      <div className="text-center p-12">
        <div className="text-red-600 mb-4">
          <svg className="mx-auto h-12 w-12 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <p className="text-lg font-medium">Failed to load images</p>
          <p className="text-sm mt-2 text-gray-600">{error}</p>
        </div>
        <button
          onClick={() => loadImages(1, true)}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
        >
          Try Again
        </button>
      </div>
    );
  }

  // 📭 Empty state when user has no images
  if (images.length === 0 && !loading) {
    return (
      <div className="text-center p-12">
        <div className="text-gray-400 mb-4">
          <svg className="mx-auto h-16 w-16 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
          <p className="text-lg font-medium text-gray-600">Your vault is empty</p>
          <p className="text-sm mt-2 text-gray-500">
            Upload some images to get started!
          </p>
        </div>
      </div>
    );
  }

  // 🖼️ Main image grid
  return (
    <div className="w-full">
      {/* Responsive grid that adapts to screen size */}
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-2 sm:gap-3 md:gap-4">
        {images.map((item) => {
          const thumbnail = item.variants?.find(v => v.variantType === 'thumbnail_gallery');

          return (
            <div
              key={item.uuid}
              className="group relative aspect-square bg-gray-100 rounded-lg overflow-hidden cursor-pointer transition-transform hover:scale-105 hover:shadow-lg"
              onClick={() => onImageClick?.(item)}
            >
              {thumbnail?.url ? (
                <>
                  <img
                    src={thumbnail.url}
                    alt={item.name || 'Vault image'}
                    className="w-full h-full object-cover"
                    loading="lazy" // ⚡ Performance: lazy load images
                  />
                  {/* Overlay with image info on hover */}
                  <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-30 transition-all duration-200 flex items-end">
                    <div className="p-2 text-white text-xs opacity-0 group-hover:opacity-100 transition-opacity">
                      <p className="truncate">{item.name || 'Untitled'}</p>
                      {item.createdAt && (
                        <p className="text-gray-200 text-xs">
                          {new Date(item.createdAt).toLocaleDateString()}
                        </p>
                      )}
                    </div>
                  </div>
                </>
              ) : (
                <div className="w-full h-full flex items-center justify-center text-gray-400">
                  <div className="text-center">
                    <svg className="mx-auto h-8 w-8 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <p className="text-xs">No preview</p>
                  </div>
                </div>
              )}
            </div>
          );
        })}
      </div>

      {/* Loading indicator for "Load More" */}
      {loadingMore && (
        <div className="text-center p-8">
          <div className="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mb-2"></div>
          <p className="text-sm text-gray-600">Loading more images...</p>
        </div>
      )}

      {/* Load More button */}
      {hasMore && !loadingMore && !loading && (
        <div className="text-center p-8">
          <button
            onClick={loadMore}
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium"
          >
            Load More
          </button>
        </div>
      )}
    </div>
  );
}
```

**Key Features Explained:**

1. **OAuth Authentication**: Uses `accessToken` prop for secure authentication
2. **Responsive Grid**: Adapts from 2 to 6 columns based on screen size
3. **Lazy Loading**: Images load only when they're about to be visible
4. **State Management**: Separate loading states for initial load vs. pagination
5. **Error Handling**: Comprehensive error states with retry functionality
6. **Performance**: Optimized with `useCallback` to prevent unnecessary re-renders

Now that you understand how to display existing images, let's move on to the exciting part: implementing multipart upload!

## Step 2: Implement Multipart Upload

Here's where we get to the core of this tutorial. We'll build a complete multipart upload system that handles large files efficiently, provides real-time progress feedback, and gracefully handles errors.

### Understanding the Upload Flow (Again, but with Code)

Before we dive into implementation, let's revisit the 3-phase flow with more technical detail:

**Phase 1: Initiate Upload**

* Client tells server: "I want to upload a 50MB image called 'vacation.jpg'"
* Server creates a database record for the media
* Server tells cloud storage: "Prepare for a multipart upload"
* Server returns: `{mediaUuid: "abc-123", uploadId: "xyz-789"}`

**Phase 2: Upload Parts**

* Client splits file into 10MB chunks (5 chunks for our 50MB file)
* For each chunk:
  * Client asks: "Where do I upload chunk 3?"
  * Server returns a signed URL (valid for \~15 minutes)
  * Client uploads chunk directly to cloud storage
  * Storage returns an ETag (proof of successful upload)

**Phase 3: Finalize Upload**

* Client tells server: "All chunks uploaded, here are the ETags"
* Server tells storage: "Combine all chunks into final file"
* Storage combines chunks and confirms success
* Server starts processing pipeline (thumbnail generation, etc.)

### Enhanced API Client with Upload Methods

Let's extend our API client to support the multipart upload flow:

```typescript
// lib/fanvue-api.ts (continued)
// Add these methods to the existing FanvueAPI class

export interface UploadPart {
  ETag?: string;
  PartNumber: number;
}

export interface InitiateUploadResponse {
  mediaUuid: string;
  uploadId: string;
}

// Add these methods to your existing FanvueAPI class:

  // 🚀 Phase 1: Create upload session
  async createUploadSession(file: File): Promise<InitiateUploadResponse> {
    const response = await this.makeRequest('/media/uploads', {
      method: 'POST',
      body: JSON.stringify({
        name: file.name,          // Display name for the media
        filename: file.name,      // Original filename
        mediaType: 'image',       // We're focusing on images
      }),
    });

    return response.json();
  }

  // 📍 Phase 2a: Get signed URL for specific chunk
  async getPartUrl(
    uploadId: string,
    partNumber: number
  ): Promise<string> {
    const response = await this.makeRequest(`/media/uploads/${uploadId}/parts/${partNumber}/url`, {
      method: 'GET',
    });

    // Response is plain text (the signed URL)
    return response.text();
  }

  // 📦 Phase 2b: Upload chunk to signed URL
  async uploadPart(signedUrl: string, chunk: Blob): Promise<string> {
    // Note: This request goes directly to cloud storage, not our API
    const response = await fetch(signedUrl, {
      method: 'PUT',
      body: chunk,
      headers: {
        'Content-Type': 'application/octet-stream',
      },
      // Don't add Authorization header - signed URL handles auth
    });

    if (!response.ok) {
      throw new Error(`Part upload failed: ${response.status} ${response.statusText}`);
    }

    // Cloud storage returns ETag header as proof of successful upload
    const etag = response.headers.get('ETag');
    if (!etag) {
      throw new Error('No ETag received from part upload');
    }

    return etag;
  }

  // ✅ Phase 3: Complete upload session
  async completeUploadSession(
    uploadId: string,
    parts: UploadPart[]
  ): Promise<{ status: string }> {
    const response = await this.makeRequest(`/media/uploads/${uploadId}`, {
      method: 'PATCH',
      body: JSON.stringify({
        parts, // Array of {ETag, PartNumber} objects
      }),
    });

    return response.json();
  }
}
```

**What's happening in these upload methods:**

1. **createUploadSession**: Creates media record and starts multipart session
2. **getPartUrl**: Gets signed URL for uploading a specific chunk using RESTful URL structure
3. **uploadPart**: Uploads chunk directly to cloud storage (bypasses our API)
4. **completeUploadSession**: Tells server to combine all chunks into final file using PATCH method

### Error Handling for Upload Operations

Network operations can fail in many ways, especially with large file uploads. Let's add robust error handling:

```typescript
// lib/upload-errors.ts
// Structured error handling for upload operations

export class UploadError extends Error {
  constructor(
    message: string,
    public code: string,
    public retryable: boolean = false,
    public originalError?: unknown
  ) {
    super(message);
    this.name = "UploadError";
  }
}

export function handleApiError(error: any): UploadError {
  // Handle fetch abort (user cancelled)
  if (error.name === "AbortError") {
    return new UploadError("Upload cancelled by user", "CANCELLED");
  }

  const message = error.message || "Unknown error occurred";

  // File too large
  if (message.includes("413") || message.toLowerCase().includes("too large")) {
    return new UploadError("File is too large. Maximum size is 1GB.", "FILE_TOO_LARGE");
  }

  // Rate limiting (temporary issue)
  if (message.includes("429") || message.toLowerCase().includes("rate limit")) {
    return new UploadError(
      "Too many requests. Please wait a moment before retrying.",
      "RATE_LIMITED",
      true // This is retryable
    );
  }

  // Authentication issues
  if (message.includes("401") || message.includes("403")) {
    return new UploadError("Authentication failed. Please log in again.", "AUTHENTICATION_FAILED");
  }

  // Server errors (likely temporary)
  if (message.includes("5") || message.toLowerCase().includes("server error")) {
    return new UploadError(
      "Server error occurred. Please try again.",
      "SERVER_ERROR",
      true // Server errors are usually temporary
    );
  }

  // Generic network error (likely temporary)
  if (message.toLowerCase().includes("network") || message.toLowerCase().includes("fetch")) {
    return new UploadError(
      "Network error. Please check your connection and try again.",
      "NETWORK_ERROR",
      true
    );
  }

  // Unknown error
  return new UploadError(
    message,
    "UNKNOWN_ERROR",
    true // When in doubt, allow retry
  );
}
```

### Building the Upload Progress Component

Before we build the main uploader, let's create a component that shows upload progress. This provides immediate user feedback and makes the upload feel responsive:

```typescript
// components/UploadProgress.tsx
// Visual progress indicator for individual file uploads

interface UploadProgressProps {
  fileName: string;
  progress: number; // 0-100
  status: 'uploading' | 'processing' | 'completed' | 'error';
  error?: string;
  onRetry?: () => void;
  onCancel?: () => void;
}

export function UploadProgress({
  fileName,
  progress,
  status,
  error,
  onRetry,
  onCancel
}: UploadProgressProps) {
  // 📝 Dynamic text based on current status
  const getStatusText = () => {
    switch (status) {
      case 'uploading':
        return `Uploading... ${Math.round(progress)}%`;
      case 'processing':
        return 'Processing...'; // Server is creating thumbnails, etc.
      case 'completed':
        return 'Upload complete!';
      case 'error':
        return 'Upload failed';
      default:
        return 'Preparing...';
    }
  };

  // 🎨 Color scheme based on status
  const getStatusColor = () => {
    switch (status) {
      case 'uploading':
        return 'bg-blue-600';
      case 'processing':
        return 'bg-yellow-600 animate-pulse'; // Pulsing animation for processing
      case 'completed':
        return 'bg-green-600';
      case 'error':
        return 'bg-red-600';
      default:
        return 'bg-gray-400';
    }
  };

  // 🔄 Icon for current status
  const getIcon = () => {
    switch (status) {
      case 'uploading':
        return (
          <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            />
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            />
          </svg>
        );
      case 'processing':
        return (
          <svg className="w-4 h-4 animate-spin" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clipRule="evenodd" />
          </svg>
        );
      case 'completed':
        return (
          <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
          </svg>
        );
      case 'error':
        return (
          <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
          </svg>
        );
      default:
        return null;
    }
  };

  return (
    <div className="bg-white rounded-lg border border-gray-200 p-4 shadow-sm">
      {/* Header with file name and action buttons */}
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center space-x-3 min-w-0 flex-1">
          <div className={`text-white p-1 rounded ${getStatusColor().split(' ')[0]}`}>
            {getIcon()}
          </div>
          <div className="min-w-0 flex-1">
            <p className="text-sm font-medium text-gray-900 truncate" title={fileName}>
              {fileName}
            </p>
            <p className="text-xs text-gray-600">
              {getStatusText()}
            </p>
          </div>
        </div>

        {/* Action buttons */}
        <div className="flex items-center space-x-2 ml-4">
          {status === 'uploading' && onCancel && (
            <button
              onClick={onCancel}
              className="text-gray-400 hover:text-red-600 text-sm px-2 py-1 rounded transition-colors"
              title="Cancel upload"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
          {status === 'error' && onRetry && (
            <button
              onClick={onRetry}
              className="text-xs bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700 transition-colors"
            >
              Retry
            </button>
          )}
        </div>
      </div>

      {/* Progress bar */}
      <div className="w-full bg-gray-200 rounded-full h-2 mb-2">
        <div
          className={`h-2 rounded-full transition-all duration-300 ease-out ${getStatusColor()}`}
          style={{
            width: `${status === 'error' ? 100 : Math.max(progress, 2)}%`
          }}
        />
      </div>

      {/* Error message */}
      {status === 'error' && error && (
        <div className="mt-2 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-800">
          <div className="flex items-start space-x-2">
            <svg className="w-4 h-4 text-red-500 flex-shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
            <p className="flex-1">{error}</p>
          </div>
        </div>
      )}

      {/* Processing explanation */}
      {status === 'processing' && (
        <div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded text-xs text-yellow-800">
          <p className="flex items-center space-x-2">
            <svg className="w-4 h-4 text-yellow-500 animate-pulse" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
            </svg>
            <span>Creating thumbnails and optimizing your image...</span>
          </p>
        </div>
      )}
    </div>
  );
}
```

This progress component handles all the visual feedback during upload. The key features are:

1. **Status-based styling**: Different colors and icons for each state
2. **Progress calculation**: Smooth progress bar with minimum 2% width for visibility
3. **Interactive elements**: Cancel and retry buttons when appropriate
4. **Educational messaging**: Explains what "processing" means to users

### Building the Main Upload Component

Now comes the centerpiece: a React component that handles the complete multipart upload flow. This component coordinates file chunking, parallel uploads, progress tracking, and error recovery.

```typescript
'use client';

// components/ImageUploader.tsx
// Complete multipart upload implementation with queue management

import { useState, useCallback, useRef } from 'react';
import { FanvueAPI, UploadPart, handleApiError, UploadError } from '../lib/fanvue-api';
import { UploadProgress } from './UploadProgress';

// Configuration constants
const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB chunks - good balance of reliability and performance
const MAX_CONCURRENT_UPLOADS = 3;    // Limit concurrent uploads to avoid overwhelming the server
const MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1GB limit
const MAX_RETRY_ATTEMPTS = 3;        // Auto-retry failed chunks up to 3 times

interface UploadTask {
  id: string;
  file: File;
  progress: number;
  status: 'uploading' | 'processing' | 'completed' | 'error';
  error?: string;
  mediaUuid?: string;
  uploadId?: string;
  abortController?: AbortController;
  retryCount: number;
}

interface ImageUploaderProps {
  accessToken: string; // 🔑 OAuth token
  onUploadComplete?: () => void;
  maxFiles?: number;
  acceptedTypes?: string[];
  disabled?: boolean;
}

export function ImageUploader({
  accessToken,
  onUploadComplete,
  maxFiles = 10,
  acceptedTypes = ['image/*'],
  disabled = false
}: ImageUploaderProps) {
  const [uploads, setUploads] = useState<UploadTask[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Queue management for concurrent uploads
  const uploadQueueRef = useRef<(() => Promise<void>)[]>([]);
  const runningUploads = useRef(0);

  const api = new FanvueAPI(accessToken);

  // 🔄 Helper to update upload state
  const updateUpload = useCallback((id: string, updates: Partial<UploadTask>) => {
    setUploads(prev => prev.map(upload =>
      upload.id === id ? { ...upload, ...updates } : upload
    ));
  }, []);

  const removeUpload = useCallback((id: string) => {
    setUploads(prev => prev.filter(upload => upload.id !== id));
  }, []);

  // 🎯 Queue management - processes uploads with concurrency limit
  const processUploadQueue = useCallback(async () => {
    if (runningUploads.current >= MAX_CONCURRENT_UPLOADS || uploadQueueRef.current.length === 0) {
      return;
    }

    const uploadTask = uploadQueueRef.current.shift();
    if (uploadTask) {
      runningUploads.current++;
      try {
        await uploadTask();
      } finally {
        runningUploads.current--;
        // Process next item in queue
        setTimeout(processUploadQueue, 100);
      }
    }
  }, []);

  // 🚀 Main upload function - implements the 3-phase multipart flow
  const uploadFile = useCallback(async (file: File): Promise<void> => {
    const uploadId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const abortController = new AbortController();

    const upload: UploadTask = {
      id: uploadId,
      file,
      progress: 0,
      status: 'uploading',
      abortController,
      retryCount: 0,
    };

    setUploads(prev => [...prev, upload]);

    try {
      // 🔍 Phase 1: Create upload session
      if (abortController.signal.aborted) throw new Error('Upload cancelled');

      const initResponse = await api.createUploadSession(file);
      updateUpload(uploadId, {
        mediaUuid: initResponse.mediaUuid,
        uploadId: initResponse.uploadId,
      });

      // 📦 Phase 2: Upload parts in parallel
      const chunks = Math.ceil(file.size / CHUNK_SIZE);
      const parts: Array<{ ETag: string; PartNumber: number }> = new Array(chunks);
      const uploadPromises: Promise<void>[] = [];

      // Create upload promises for each chunk
      for (let partNumber = 1; partNumber <= chunks; partNumber++) {
        const uploadPartPromise = async () => {
          if (abortController.signal.aborted) throw new Error('Upload cancelled');

          const start = (partNumber - 1) * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, file.size);
          const chunk = file.slice(start, end);

          try {
            // Get signed URL for this specific chunk
            const partUrl = await api.getPartUrl(
              initResponse.uploadId,
              partNumber
            );

            // Upload chunk directly to cloud storage
            const etag = await api.uploadPart(partUrl, chunk);
            parts[partNumber - 1] = { ETag: etag, PartNumber: partNumber };

            // Update progress (thread-safe because we're using the part number as index)
            const completedChunks = parts.filter(Boolean).length;
            const progress = (completedChunks / chunks) * 100;
            updateUpload(uploadId, { progress });

          } catch (error) {
            throw new Error(`Failed to upload chunk ${partNumber}: ${error}`);
          }
        };

        uploadPromises.push(uploadPartPromise());

        // ⚡ Process chunks in batches to avoid overwhelming the browser
        if (uploadPromises.length >= 3) {
          await Promise.all(uploadPromises);
          uploadPromises.length = 0;
        }
      }

      // Wait for any remaining uploads
      if (uploadPromises.length > 0) {
        await Promise.all(uploadPromises);
      }

      // Verify all parts uploaded successfully
      if (parts.length !== chunks || parts.some(part => !part)) {
        throw new Error('Some chunks failed to upload');
      }

      // ✅ Phase 3: Complete upload session
      updateUpload(uploadId, { status: 'processing', progress: 100 });

      await api.completeUploadSession(
        initResponse.uploadId,
        parts
      );

      updateUpload(uploadId, {
        status: 'completed',
        progress: 100
      });

      // Notify parent component
      onUploadComplete?.();

    } catch (error) {
      const uploadError = handleApiError(error);
      updateUpload(uploadId, {
        status: 'error',
        error: uploadError.message,
      });

      // Auto-retry for retryable errors (rate limits, network issues, etc.)
      if (uploadError.retryable && upload.retryCount < MAX_RETRY_ATTEMPTS) {
        setTimeout(() => retryUpload(uploadId), 2000 * (upload.retryCount + 1));
      }
    }
  }, [accessToken, onUploadComplete, api, updateUpload]);

  // 📋 Queue upload with concurrency management
  const queueUpload = useCallback((file: File) => {
    const uploadTask = () => uploadFile(file);
    uploadQueueRef.current.push(uploadTask);
    processUploadQueue();
  }, [uploadFile, processUploadQueue]);

  // ✅ File validation before upload
  const validateFile = useCallback((file: File): string | null => {
    // Check file type
    const isValidType = acceptedTypes.some(type => {
      if (type === 'image/*') return file.type.startsWith('image/');
      return file.type === type;
    });

    if (!isValidType) {
      return 'File type not supported. Please select an image file.';
    }

    // Check file size
    if (file.size > MAX_FILE_SIZE) {
      return `File too large. Maximum size is ${MAX_FILE_SIZE / (1024 * 1024)}MB.`;
    }

    if (file.size === 0) {
      return 'File is empty.';
    }

    return null;
  }, [acceptedTypes]);

  // 📁 Handle file selection from input
  const handleFileSelect = useCallback((files: FileList | null) => {
    if (!files || disabled) return;

    const fileArray = Array.from(files);
    const currentUploads = uploads.length;

    // Check file limits
    if (currentUploads + fileArray.length > maxFiles) {
      alert(`Maximum ${maxFiles} files allowed. You can upload ${maxFiles - currentUploads} more files.`);
      return;
    }

    // Validate and queue each file
    fileArray.forEach(file => {
      const error = validateFile(file);
      if (error) {
        alert(`${file.name}: ${error}`);
        return;
      }

      queueUpload(file);
    });

    // Reset input for re-selection of same files
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, [disabled, uploads.length, maxFiles, validateFile, queueUpload]);

  // 🔄 Retry failed upload
  const retryUpload = useCallback((uploadId: string) => {
    const upload = uploads.find(u => u.id === uploadId);
    if (!upload) return;

    // Cancel any existing upload
    upload.abortController?.abort();

    // Reset state and increment retry count
    updateUpload(uploadId, {
      status: 'uploading',
      progress: 0,
      error: undefined,
      retryCount: upload.retryCount + 1,
      abortController: new AbortController(),
    });

    // Queue the retry
    queueUpload(upload.file);
  }, [uploads, updateUpload, queueUpload]);

  // ❌ Cancel upload
  const cancelUpload = useCallback((uploadId: string) => {
    const upload = uploads.find(u => u.id === uploadId);
    if (upload) {
      upload.abortController?.abort();
      removeUpload(uploadId);
    }
  }, [uploads, removeUpload]);

  // 🧹 Clear completed uploads
  const clearCompleted = useCallback(() => {
    setUploads(prev => prev.filter(upload => upload.status !== 'completed'));
  }, []);

  const completedCount = uploads.filter(u => u.status === 'completed').length;
  const hasUploads = uploads.length > 0;

  return (
    <div className="w-full">
      {/* File Selection Area */}
      <div
        className={`relative border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
          disabled
            ? 'border-gray-200 bg-gray-50 cursor-not-allowed'
            : 'border-gray-300 hover:border-blue-400 hover:bg-blue-50 cursor-pointer'
        }`}
        onClick={() => !disabled && fileInputRef.current?.click()}
      >
        <input
          ref={fileInputRef}
          type="file"
          multiple
          accept={acceptedTypes.join(',')}
          onChange={(e) => handleFileSelect(e.target.files)}
          className="hidden"
          disabled={disabled}
        />

        <div className={`${disabled ? 'text-gray-400' : 'text-gray-600'}`}>
          <svg
            className="mx-auto h-12 w-12 mb-4"
            stroke="currentColor"
            fill="none"
            viewBox="0 0 48 48"
            aria-hidden="true"
          >
            <path
              d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
              strokeWidth={2}
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>
          <p className="text-lg font-medium">
            {disabled ? 'Upload disabled' : 'Upload images to your vault'}
          </p>
          <p className="text-sm mt-1">
            {disabled
              ? 'Please authenticate to upload files'
              : 'Click to select files'
            }
          </p>
          <p className="text-xs mt-2 text-gray-500">
            Max {maxFiles} files, up to {MAX_FILE_SIZE / (1024 * 1024)}MB each
          </p>
        </div>
      </div>

      {/* Upload List */}
      {hasUploads && (
        <div className="mt-6 space-y-3">
          <div className="flex items-center justify-between">
            <h3 className="text-lg font-medium">
              Uploads ({uploads.length})
            </h3>
            {completedCount > 0 && (
              <button
                onClick={clearCompleted}
                className="text-sm text-gray-500 hover:text-gray-700 underline"
              >
                Clear completed ({completedCount})
              </button>
            )}
          </div>

          <div className="space-y-3 max-h-96 overflow-y-auto">
            {uploads.map(upload => (
              <UploadProgress
                key={upload.id}
                fileName={upload.file.name}
                progress={upload.progress}
                status={upload.status}
                error={upload.error}
                onRetry={() => retryUpload(upload.id)}
                onCancel={
                  upload.status === 'uploading'
                    ? () => cancelUpload(upload.id)
                    : undefined
                }
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

**Key Implementation Details:**

1. **Chunking Strategy**: Files are split into 10MB chunks for optimal balance of reliability and performance
2. **Concurrency Control**: Maximum 3 concurrent uploads to avoid overwhelming the server
3. **Progress Tracking**: Real-time progress updates as chunks complete
4. **Error Recovery**: Automatic retry for network issues and rate limits
5. **User Control**: Users can cancel uploads and retry failed ones
6. **Queue Management**: Multiple files are queued and processed efficiently

### Understanding the Upload Logic

Let's break down the complex upload logic step by step:

**File Validation**

* Checks file type matches accepted formats
* Ensures file size is within limits
* Provides clear error messages for invalid files

**Upload Orchestration**

1. **Initiate**: Create media record and get upload session ID
2. **Chunk Processing**: Split file and upload chunks in parallel batches
3. **Progress Tracking**: Update UI as each chunk completes
4. **Finalization**: Combine chunks server-side and start processing

**Error Handling Strategy**

* **Network Errors**: Auto-retry with exponential backoff
* **Rate Limits**: Wait and retry automatically
* **File Errors**: Show user-friendly messages
* **Cancellation**: Clean up resources properly

This completes our multipart upload implementation! The component handles all the complexity of chunking, uploading, and error recovery while providing a clean interface for users.

## Step 3: Bringing It All Together

Now let's combine our PhotoGrid and ImageUploader components into a complete vault page that demonstrates the full user experience.

### Creating the Vault Page

Here's how all our components work together in a production-ready vault interface:

```typescript
// app/vault/page.tsx
import { Suspense } from 'react';
import { VaultContent } from './VaultContent';

export default function VaultPage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            My Vault
          </h1>
          <p className="text-gray-600">
            Upload and manage your images with advanced multipart upload technology
          </p>
        </div>

        <Suspense fallback={
          <div className="flex items-center justify-center p-12">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
          </div>
        }>
          <VaultContent />
        </Suspense>
      </div>
    </div>
  );
}
```

### The Main Vault Component

```typescript
'use client';

// app/vault/VaultContent.tsx
// Handles authentication and coordinates the photo grid with uploader

import { useState, useEffect } from 'react';
import { PhotoGrid } from '../../components/PhotoGrid';
import { ImageUploader } from '../../components/ImageUploader';
import { getCurrentUser } from '../../lib/fanvue';

export function VaultContent() {
  const [user, setUser] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [refreshKey, setRefreshKey] = useState(0);

  // 🔐 Get authenticated user with OAuth token
  useEffect(() => {
    async function loadUser() {
      try {
        const currentUser = await getCurrentUser();
        if (!currentUser) {
          setError('Please log in to access your vault');
          return;
        }
        setUser(currentUser);
      } catch (err) {
        setError('Authentication failed. Please log in again.');
        console.error('Failed to get current user:', err);
      } finally {
        setLoading(false);
      }
    }

    loadUser();
  }, []);

  // 🔄 Refresh photo grid when uploads complete
  const handleUploadComplete = () => {
    setRefreshKey(prev => prev + 1);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-12">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-4"></div>
          <p className="text-gray-600">Loading your vault...</p>
        </div>
      </div>
    );
  }

  if (error || !user) {
    return (
      <div className="text-center p-12">
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-6 max-w-md mx-auto">
          <svg className="mx-auto h-12 w-12 text-yellow-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
          </svg>
          <h3 className="text-lg font-medium text-yellow-800 mb-2">
            Authentication Required
          </h3>
          <p className="text-yellow-700 mb-4">
            {error || 'Please log in to access your vault and upload images.'}
          </p>
          <a
            href="/"
            className="inline-flex items-center px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 transition-colors"
          >
            <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
            </svg>
            Back to Home
          </a>
        </div>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
      {/* Photo Grid - 2/3 width on large screens */}
      <div className="lg:col-span-2">
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-semibold text-gray-900">Your Images</h2>
            <div className="flex items-center space-x-2 text-sm text-gray-500">
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
              </svg>
              <span>Logged in as {user.username || user.email}</span>
            </div>
          </div>

          <PhotoGrid
            accessToken={user.accessToken} // 🔑 Pass OAuth token
            refreshTrigger={refreshKey}
            onImageClick={(item) => {
              console.log('Clicked image:', item);
              // Here you could open a modal, navigate to detail page, etc.
            }}
          />
        </div>
      </div>

      {/* Upload Panel - 1/3 width on large screens */}
      <div>
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h2 className="text-xl font-semibold text-gray-900 mb-6">Upload New Images</h2>

          <ImageUploader
            accessToken={user.accessToken} // 🔑 Pass OAuth token
            onUploadComplete={handleUploadComplete}
            maxFiles={10}
            acceptedTypes={['image/*']}
          />

          {/* Educational Tips */}
          <div className="mt-6 p-4 bg-blue-50 rounded-lg">
            <h3 className="text-sm font-medium text-blue-900 mb-2">RESTful Multipart Upload</h3>
            <ul className="text-xs text-blue-800 space-y-1">
              <li>• POST /uploads - Create upload session</li>
              <li>• GET /uploads/{id}/parts/{n}/url - Get signed URLs</li>
              <li>• PATCH /uploads/{id} - Complete upload</li>
              <li>• Files split into 10MB chunks for reliability</li>
              <li>• Real-time progress tracking per file</li>
            </ul>
          </div>
        </div>

        {/* API Demo Information */}
        <div className="mt-6 bg-gray-50 rounded-lg border border-gray-200 p-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">About This Demo</h3>
          <p className="text-sm text-gray-600 mb-4">
            This vault demonstrates the Fanvue API's advanced multipart upload capabilities:
          </p>
          <ul className="text-sm text-gray-600 space-y-2">
            <li className="flex items-start space-x-2">
              <svg className="w-4 h-4 text-green-500 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
              <span>OAuth Bearer token authentication</span>
            </li>
            <li className="flex items-start space-x-2">
              <svg className="w-4 h-4 text-green-500 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
              <span>RESTful 3-phase multipart upload flow</span>
            </li>
            <li className="flex items-start space-x-2">
              <svg className="w-4 h-4 text-green-500 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
              <span>Automatic thumbnail generation</span>
            </li>
            <li className="flex items-start space-x-2">
              <svg className="w-4 h-4 text-green-500 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
              </svg>
              <span>Production-ready error handling</span>
            </li>
          </ul>

          <div className="mt-4 pt-4 border-t border-gray-200">
            <a
              href="https://api.fanvue.com/docs"
              target="_blank"
              rel="noopener noreferrer"
              className="text-sm text-blue-600 hover:text-blue-700 font-medium inline-flex items-center"
            >
              View Full API Documentation
              <svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
              </svg>
            </a>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### Key Architecture Decisions

**Layout & UX**

* **Responsive Grid**: 3-column layout on desktop, single column on mobile
* **Progressive Enhancement**: Works without JavaScript for basic functionality
* **Clear Visual Hierarchy**: Existing images prominent, upload panel secondary

**State Management**

* **Centralized Auth**: Single source of truth for user authentication
* **Optimistic Updates**: UI updates immediately, syncs with server
* **Error Boundaries**: Graceful handling of authentication and network failures

**Performance Considerations**

* **Lazy Loading**: Images load as needed
* **Suspense Boundaries**: Non-blocking loading states
* **Efficient Re-renders**: Minimal re-renders through proper key usage

## Testing Your Implementation

Now that you have a complete multipart upload system, here's how to test it thoroughly:

### 1. Basic Functionality Tests

**Photo Grid Loading**

* Empty vault state displays correctly
* Loading spinner appears during API calls
* Error message shows with retry button for network failures
* Images display properly with hover effects
* "Load More" button works for pagination

**File Upload Tests**

* File picker opens and accepts image files
* Multiple file selection works correctly
* File validation rejects invalid types and sizes
* Progress tracking updates in real-time
* Completed uploads refresh the photo grid

### 2. Multipart Upload Flow Testing

**Small Files (\< 10MB)**

* Should upload in single chunk
* Progress should jump quickly to 100%
* Processing state should appear briefly

**Large Files (> 10MB)**

* Should split into multiple chunks
* Progress should increase gradually
* Each chunk upload should be visible in network tab

**Very Large Files (> 100MB)**

* Should handle many chunks without browser freezing
* Memory usage should remain stable
* Upload should complete successfully

### 3. Error Scenario Testing

**Network Interruptions**

* Disconnect internet during upload
* Should show retry button when reconnected
* Auto-retry should work for retryable errors

**Authentication Failures**

* Use expired or invalid OAuth token
* Should show authentication error message
* Should redirect to login when appropriate

**Rate Limiting**

* Upload many files simultaneously
* Should handle 429 responses gracefully
* Should implement exponential backoff

**File Size Limits**

* Try uploading files over 1GB
* Should show clear error message before upload starts

### 4. User Experience Testing

**Visual Feedback**

* All loading states have appropriate spinners
* Error states have clear messaging
* Success states provide confirmation

**Responsive Design**

* Grid layout adapts to different screen sizes
* Upload interface works on mobile devices
* Touch interactions work properly

**Accessibility**

* Keyboard navigation works throughout
* Screen readers can announce upload progress
* Color contrast meets accessibility standards

## Advanced Features

Once you've mastered the basic multipart upload, consider adding these enhancements:

### Upload Queue Management

```typescript
// Enhanced queue with priority and retry logic
class AdvancedUploadQueue {
  private highPriorityQueue: UploadTask[] = [];
  private normalQueue: UploadTask[] = [];

  addHighPriority(task: UploadTask) {
    this.highPriorityQueue.push(task);
  }

  // Process high priority tasks first
  getNextTask(): UploadTask | null {
    return this.highPriorityQueue.shift() || this.normalQueue.shift() || null;
  }
}
```

### Upload Analytics

```typescript
// Track upload performance for optimization
interface UploadMetrics {
  fileSize: number;
  chunkSize: number;
  totalTime: number;
  avgChunkTime: number;
  retryCount: number;
  networkSpeed: number;
}

function trackUploadMetrics(upload: UploadTask): UploadMetrics {
  // Implementation for gathering upload analytics
  // Use this data to optimize chunk sizes and retry strategies
}
```

### Drag and Drop Enhancement

```typescript
// Add drag-and-drop for better UX
function useDragAndDrop(onFilesDropped: (files: File[]) => void) {
  const [isDragging, setIsDragging] = useState(false);

  const handleDrop = (e: DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    const files = Array.from(e.dataTransfer?.files || []);
    onFilesDropped(files);
  };

  // Return drag handlers and state
  return { isDragging, dragHandlers: { onDrop: handleDrop } };
}
```

## Performance Optimizations

### 1. Dynamic Chunk Sizing

```typescript
// Adjust chunk size based on network speed
function calculateOptimalChunkSize(networkSpeed: number): number {
  if (networkSpeed > 10000) return 20 * 1024 * 1024; // 20MB for fast networks
  if (networkSpeed > 1000) return 10 * 1024 * 1024; // 10MB for medium
  return 5 * 1024 * 1024; // 5MB for slow networks
}
```

### 2. Connection Pooling

```typescript
// Reuse connections for better performance
class ConnectionPool {
  private activeConnections = new Set<string>();
  private maxConnections = 6; // Browser limit

  canMakeRequest(): boolean {
    return this.activeConnections.size < this.maxConnections;
  }
}
```

### 3. Image Preprocessing

```typescript
// Compress images client-side before upload
async function compressImage(file: File, quality: number = 0.8): Promise<Blob> {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const img = new Image();

  return new Promise((resolve) => {
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx?.drawImage(img, 0, 0);
      canvas.toBlob((blob) => resolve(blob!), "image/jpeg", quality);
    };
    img.src = URL.createObjectURL(file);
  });
}
```

## Security Considerations

### 1. Client-Side Validation is Not Enough

```typescript
// Always validate on server-side too
const validateFile = (file: File) => {
  // Client-side validation for UX
  if (!file.type.startsWith("image/")) {
    throw new Error("Invalid file type");
  }

  // Note: Server MUST also validate file type, size, and content
};
```

### 2. Secure Token Handling

```typescript
// Never log or expose OAuth tokens
class SecureAPIClient {
  private token: string;

  constructor(token: string) {
    this.token = token;
    // Never console.log(this.token) or expose it in errors
  }

  makeRequest(url: string) {
    return fetch(url, {
      headers: {
        Authorization: `Bearer ${this.token}`, // Keep this secure
      },
    });
  }
}
```

### 3. Content Security Policy

```typescript
// Add CSP headers to prevent XSS
const cspHeader = {
  "Content-Security-Policy":
    "default-src 'self'; " +
    "img-src 'self' https://cdn.fanvue.com; " +
    "connect-src 'self' https://api.fanvue.com",
};
```

## Troubleshooting Common Issues

### Upload Fails Immediately

* **Check OAuth token**: Ensure `read:media` and `write:media` scopes
* **Verify file type**: Only images are supported in this implementation
* **Check file size**: Must be under 1GB limit
* **Network connectivity**: Ensure API endpoint is reachable

### Progress Bar Stuck at 0%

* **Check initiate response**: Verify mediaUuid and uploadId are received
* **Check part URLs**: Ensure signed URLs are being generated
* **Network issues**: Temporary connectivity problems

### Images Not Appearing After Upload

* **Processing time**: Large images may take minutes to process
* **Status checking**: Verify images reach 'ready' status
* **Variant generation**: Thumbnails must be created before display
* **Refresh timing**: Grid should refresh after successful upload

### Memory Issues with Large Files

* **Chunk size**: Reduce from 10MB to 5MB for slower devices
* **Concurrency**: Reduce MAX\_CONCURRENT\_UPLOADS from 3 to 2
* **File cleanup**: Ensure File objects are garbage collected

## Next Steps

This tutorial provides a solid foundation for multipart uploads. Consider extending with:

* **Resume Capability**: Store upload state in localStorage
* **Background Uploads**: Continue uploads when tab is hidden
* **Bulk Operations**: Select and delete multiple images
* **Advanced Metadata**: EXIF data extraction and display
* **Image Editing**: Basic crop/rotate before upload

## Production Checklist

Before deploying your multipart upload vault to production:

* [ ] **OAuth tokens stored securely** - Never expose tokens client-side
* [ ] **Error tracking implemented** - Use Sentry, LogRocket, or similar
* [ ] **Upload limits configured** - File size, count, and rate limits
* [ ] **User feedback for all states** - Loading, error, and success messaging
* [ ] **Mobile-responsive design tested** - Upload works on all devices
* [ ] **Accessibility features added** - Screen reader support, keyboard navigation
* [ ] **Rate limiting handled gracefully** - Exponential backoff, user messaging
* [ ] **Image optimization implemented** - Client-side compression where appropriate
* [ ] **Content security policies configured** - CSP headers to prevent XSS
* [ ] **Performance monitoring** - Track upload success rates and timing
* [ ] **Comprehensive error logging** - Log all upload failures for debugging
* [ ] **Backup recovery plan** - Handle corrupted uploads gracefully

***

*This tutorial demonstrates a complete multipart upload implementation using OAuth Bearer tokens and modern React patterns. For questions about specific API endpoints, see the [API Reference](/docs/reference/media).*


# Sending Mass Messages

# Sending Mass Messages

Learn how to send messages to multiple users at once using smart lists and custom lists. This tutorial covers the two-step process: discovering your audience lists and sending targeted mass messages.

## Overview

Mass messaging allows you to send a single message to many users efficiently. Instead of sending individual messages, you can target entire audience segments defined by:

* **Smart Lists**: Pre-built audience segments (all fans, subscribers, top spenders, etc.)
* **Custom Lists**: User-created lists for custom audience targeting

### The Two-Step Flow

```mermaid
graph LR
    A[Step 1: Get Lists] --> B[Smart Lists]
    A --> C[Custom Lists]
    B --> D[Step 2: Send Mass Message]
    C --> D
    D --> E[Message Sent to Recipients]
```

**Step 1: Discover Available Lists**

* Fetch smart lists to see pre-built audience segments
* Fetch custom lists to see user-created segments
* Optionally fetch members to preview recipients

**Step 2: Send the Mass Message**

* Select lists to include (required)
* Optionally select lists to exclude
* Send with text, media, or pay-to-view content

<Note>
  #### Authentication Required

  Mass messaging requires OAuth with these scopes:

  * `write:chat` - Permission to send messages
  * `read:fan` - Permission to read fan/subscriber data

  See the [OAuth Tutorial](/docs/authentication/quick-start) for setup instructions.
</Note>

## Prerequisites

* OAuth authentication with required scopes (see note above)
* Basic familiarity with REST APIs
* Understanding of your Fanvue audience structure

## Step 1: Discovering Your Lists

Before sending a mass message, you need to know which lists are available. There are two types:

### Smart Lists (Pre-built Audiences)

Smart lists are automatically maintained audience segments based on user behavior and relationships.

#### Fetch All Smart Lists

```bash
curl -X GET "https://api.fanvue.com/chats/lists/smart" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26"
```

**Response:**

```json
[
  {
    "uuid": "all_fans",
    "name": "All Fans",
    "count": 1250
  },
  {
    "uuid": "subscribers",
    "name": "Active Subscribers",
    "count": 450
  },
  {
    "uuid": "expired_subscribers",
    "name": "Expired Subscribers",
    "count": 180
  }
]
```

**Common Smart Lists:**

* `all_fans` - Everyone who follows you
* `subscribers` - Users with active subscriptions
* `expired_subscribers` - Users whose subscriptions expired
* `top_spenders` - Your highest spending fans

<Info>
  Smart list identifiers are lowercase with underscores. The actual values available depend on your
  account configuration.
</Info>

#### Preview Smart List Members (Optional)

```bash
curl -X GET "https://api.fanvue.com/chats/lists/smart/subscribers?page=1&size=20" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26"
```

**Response:**

```json
{
  "data": [
    {
      "uuid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "displayName": "Sarah Miller",
      "handle": "sarahmiller",
      "isCreator": false
    }
  ],
  "pagination": {
    "page": 1,
    "size": 20,
    "hasMore": true
  }
}
```

### Custom Lists (User-created Audiences)

Custom lists are manually created segments for specific targeting.

#### Fetch All Custom Lists

```bash
curl -X GET "https://api.fanvue.com/chats/lists/custom?page=1&size=20" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26"
```

**Response:**

```json
{
  "data": [
    {
      "uuid": "f1e2d3c4-b5a6-9788-c0d1-e2f3g4h5i6j7",
      "name": "VIP Supporters",
      "count": 42,
      "createdAt": "2025-09-15T10:30:00Z"
    },
    {
      "uuid": "a9b8c7d6-e5f4-3210-9876-fedcba098765",
      "name": "Content Feedback Group",
      "count": 28,
      "createdAt": "2025-08-20T14:15:00Z"
    }
  ],
  "pagination": {
    "page": 1,
    "size": 20,
    "hasMore": false
  }
}
```

#### Preview Custom List Members (Optional)

```bash
curl -X GET "https://api.fanvue.com/chats/lists/custom/f1e2d3c4-b5a6-9788-c0d1-e2f3g4h5i6j7?page=1&size=20" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26"
```

**Response structure is the same as smart list members.**

### TypeScript Example: Fetching Lists

```typescript
interface SmartList {
  uuid: string;
  name: string;
  count: number;
}

interface CustomList {
  uuid: string;
  name: string;
  count: number;
  createdAt: string;
}

async function discoverLists(accessToken: string) {
  const headers = {
    Authorization: `Bearer ${accessToken}`,
    "X-Fanvue-API-Version": "2025-06-26",
  };

  // Fetch smart lists
  const smartListsRes = await fetch("https://api.fanvue.com/chats/lists/smart", {
    headers,
  });
  const smartLists: SmartList[] = await smartListsRes.json();

  // Fetch custom lists (first page)
  const customListsRes = await fetch("https://api.fanvue.com/chats/lists/custom?page=1&size=20", {
    headers,
  });
  const customListsData = await customListsRes.json();
  const customLists: CustomList[] = customListsData.data;

  return { smartLists, customLists };
}

// Usage
const { smartLists, customLists } = await discoverLists("YOUR_ACCESS_TOKEN");
console.log("Smart Lists:", smartLists);
console.log("Custom Lists:", customLists);
```

## Step 2: Sending Mass Messages

Once you know your available lists, you can send a mass message to one or more lists.

### Basic Mass Message Request

```bash
curl -X POST "https://api.fanvue.com/chats/mass-messages" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26" \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Hey everyone! New content is now available on my page!",
    "includedLists": {
      "smartListUuids": ["subscribers"]
    }
  }'
```

**Response:**

```json
{
  "id": "f1e2d3c4-b5a6-9788-c0d1-e2f3g4h5i6j7",
  "recipientCount": 450,
  "createdAt": "2025-10-03T12:00:00Z"
}
```

### Request Schema

```typescript
interface MassMessageRequest {
  text?: string; // Message text (optional if media provided)
  mediaUuids?: string[]; // Array of media UUIDs
  price?: number | null; // Price in cents for pay-to-view (requires media)
  includedLists: {
    smartListUuids?: string[]; // Smart list IDs to include
    customListUuids?: string[]; // Custom list UUIDs to include
  };
  excludedLists?: {
    // Optional: lists to exclude
    smartListUuids?: string[];
    customListUuids?: string[];
  };
}
```

**Validation Rules:**

* Must provide either `text` or `mediaUuids` (or both)
* At least one list must be included
* If `price` is set, `mediaUuids` must be provided
* Price must be in cents (e.g., 999 = \$9.99) with a minimum of 200 (i.e., \$2.00)
* Smart list identifiers are lowercase (e.g., `"subscribers"`, not `"SUBSCRIBERS"`)

## Practical Examples

### Example 1: Send to All Subscribers

```bash
curl -X POST "https://api.fanvue.com/chats/mass-messages" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26" \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Thank you for being a subscriber! 💜",
    "includedLists": {
      "smartListUuids": ["subscribers"]
    }
  }'
```

### Example 2: Send to Multiple Lists

Target both active and expired subscribers:

```bash
curl -X POST "https://api.fanvue.com/chats/mass-messages" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26" \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Special offer: 50% off subscription renewal!",
    "includedLists": {
      "smartListUuids": ["subscribers", "expired_subscribers"]
    }
  }'
```

### Example 3: Send to Custom List with Exclusions

Send to VIP list but exclude users who already received a similar message:

```bash
curl -X POST "https://api.fanvue.com/chats/mass-messages" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26" \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Exclusive VIP content just for you!",
    "includedLists": {
      "customListUuids": ["f1e2d3c4-b5a6-9788-c0d1-e2f3g4h5i6j7"]
    },
    "excludedLists": {
      "customListUuids": ["a9b8c7d6-e5f4-3210-9876-fedcba098765"]
    }
  }'
```

### Example 4: Send Pay-to-View Message with Media

Send a message with media that requires payment to unlock:

```bash
curl -X POST "https://api.fanvue.com/chats/mass-messages" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26" \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Exclusive content available now!",
    "mediaUuids": ["a1b2c3d4-e5f6-7890-abcd-ef1234567890"],
    "price": 999,
    "includedLists": {
      "smartListUuids": ["all_fans"]
    }
  }'
```

<Info>
  Price is specified in cents. In this example, `999` represents $9.99. Minimum price is 200 cents
    ($2.00).
</Info>

### Example 5: Combine Smart and Custom Lists

```bash
curl -X POST "https://api.fanvue.com/chats/mass-messages" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "X-Fanvue-API-Version: 2025-06-26" \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Big announcement coming soon!",
    "includedLists": {
      "smartListUuids": ["subscribers"],
      "customListUuids": ["f1e2d3c4-b5a6-9788-c0d1-e2f3g4h5i6j7"]
    }
  }'
```

## Complete TypeScript Implementation

Here's a full example combining list discovery and mass messaging:

```typescript
interface MassMessageRequest {
  text?: string;
  mediaUuids?: string[];
  price?: number | null; // Price in cents (e.g., 999 = $9.99)
  includedLists: {
    smartListUuids?: string[];
    customListUuids?: string[];
  };
  excludedLists?: {
    smartListUuids?: string[];
    customListUuids?: string[];
  };
}

interface MassMessageResponse {
  id: string;
  recipientCount: number;
  createdAt: string;
}

class MassMessagingService {
  private baseUrl = "https://api.fanvue.com";
  private accessToken: string;

  constructor(accessToken: string) {
    this.accessToken = accessToken;
  }

  private async request(endpoint: string, options: RequestInit = {}) {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        "X-Fanvue-API-Version": "2025-06-26",
        "Content-Type": "application/json",
        ...options.headers,
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.message || `HTTP ${response.status}: ${response.statusText}`);
    }

    return response.json();
  }

  // Step 1: Get available lists
  async getSmartLists() {
    return this.request("/chats/lists/smart");
  }

  async getCustomLists(page = 1, size = 20) {
    return this.request(`/chats/lists/custom?page=${page}&size=${size}`);
  }

  async getSmartListMembers(listId: string, page = 1, size = 20) {
    return this.request(`/chats/lists/smart/${listId}?page=${page}&size=${size}`);
  }

  async getCustomListMembers(listUuid: string, page = 1, size = 20) {
    return this.request(`/chats/lists/custom/${listUuid}?page=${page}&size=${size}`);
  }

  // Step 2: Send mass message
  async sendMassMessage(request: MassMessageRequest): Promise<MassMessageResponse> {
    return this.request("/chats/mass-messages", {
      method: "POST",
      body: JSON.stringify(request),
    });
  }
}

// Example usage
async function main() {
  const service = new MassMessagingService("YOUR_ACCESS_TOKEN");

  try {
    // Step 1: Discover available lists
    console.log("📋 Fetching available lists...");
    const smartLists = await service.getSmartLists();
    const customListsData = await service.getCustomLists();

    console.log("Smart Lists:", smartLists);
    console.log("Custom Lists:", customListsData.data);

    // Step 2: Send mass message to subscribers
    console.log("\n📤 Sending mass message...");
    const result = await service.sendMassMessage({
      text: "Hello everyone! Thank you for your support!",
      includedLists: {
        smartListUuids: ["subscribers"],
      },
    });

    console.log("✅ Mass message sent!");
    console.log(`   Message ID: ${result.id}`);
    console.log(`   Recipients: ${result.recipientCount}`);
    console.log(`   Sent at: ${result.createdAt}`);
  } catch (error) {
    console.error("❌ Error:", error);
  }
}
```

## Best Practices

### 1. Start Small

When testing, start with a small custom list or use the preview feature to understand your audience:

```typescript
// Preview recipients before sending
const preview = await service.getSmartListMembers("subscribers", 1, 5);
console.log("First 5 recipients:", preview.data);

// Then send to the full list
const result = await service.sendMassMessage({
  text: "Test message",
  includedLists: { smartListUuids: ["subscribers"] },
});
```

### 2. Handle Rate Limits

The mass messages endpoint has rate limits. Handle them gracefully:

```typescript
async function sendWithRetry(service: MassMessagingService, request: MassMessageRequest) {
  let retries = 0;
  const maxRetries = 3;

  while (retries < maxRetries) {
    try {
      return await service.sendMassMessage(request);
    } catch (error: any) {
      if (error.message.includes("429") && retries < maxRetries - 1) {
        // Rate limited - wait and retry
        const waitTime = Math.pow(2, retries) * 1000; // Exponential backoff
        console.log(`Rate limited. Waiting ${waitTime}ms before retry...`);
        await new Promise((resolve) => setTimeout(resolve, waitTime));
        retries++;
      } else {
        throw error;
      }
    }
  }
}
```

### 3. Validate Before Sending

```typescript
function validateMassMessageRequest(request: MassMessageRequest): string | null {
  // Must have text or media
  if (!request.text && !request.mediaUuids?.length) {
    return "Must provide either text or media";
  }

  // Must have at least one included list
  const hasIncludedLists =
    (request.includedLists.smartListUuids?.length ?? 0) > 0 ||
    (request.includedLists.customListUuids?.length ?? 0) > 0;

  if (!hasIncludedLists) {
    return "Must include at least one list";
  }

  // Price requires media
  if (request.price && !request.mediaUuids?.length) {
    return "Pay-to-view messages require media";
  }

  return null; // Valid
}

// Usage
const error = validateMassMessageRequest(myRequest);
if (error) {
  console.error("Invalid request:", error);
  return;
}
```

### 4. Track Send History

Store mass message results for analytics:

```typescript
interface SendRecord {
  messageId: string;
  recipientCount: number;
  sentAt: string;
  lists: string[];
  text: string;
}

async function sendAndTrack(
  service: MassMessagingService,
  request: MassMessageRequest
): Promise<SendRecord> {
  const result = await service.sendMassMessage(request);

  const record: SendRecord = {
    messageId: result.id,
    recipientCount: result.recipientCount,
    sentAt: result.createdAt,
    lists: [
      ...(request.includedLists.smartListUuids || []),
      ...(request.includedLists.customListUuids || []),
    ],
    text: request.text || "(media only)",
  };

  // Save to your database or analytics service
  console.log("Send record:", record);

  return record;
}
```

## Troubleshooting

### "At least one list must be provided"

Ensure you're providing at least one list in `includedLists`:

```typescript
// ❌ Wrong - empty lists
{
  includedLists: {
  }
}

// ✅ Correct - at least one list
{
  includedLists: {
    smartListUuids: ["subscribers"];
  }
}
```

### "Smart list not found"

Smart list identifiers must be lowercase:

```typescript
// ❌ Wrong - uppercase
{
  smartListUuids: ["SUBSCRIBERS"];
}

// ✅ Correct - lowercase
{
  smartListUuids: ["subscribers"];
}
```

### 403 Forbidden Error

Verify you have the required OAuth scopes:

* `write:chat`
* `read:fan`

Check your OAuth configuration includes both scopes.

### Empty recipientCount

If `recipientCount` is 0, the lists might be empty or exclusions removed all recipients:

```typescript
// Check list counts first
const smartLists = await service.getSmartLists();
const subscriberList = smartLists.find((l) => l.uuid === "subscribers");
console.log("Subscribers count:", subscriberList?.count);
```

## Additional Resources

* [OAuth Authentication](/docs/authentication/quick-start) - Set up OAuth with required scopes
* [API Reference: Send Mass Message](/docs/reference/chats/send-mass-message) - Full endpoint documentation
* [API Reference: Chat Lists](/docs/reference/chat-lists) - List endpoints reference
* [Rate Limits](/docs/authentication/rate-limits) - Understanding API rate limits


# Security Guidelines

Building a secure application is crucial for protecting your users' data and maintaining their trust. This guide provides a set of basic security principles and best practices that every developer should follow.

## Authentication vs. Authorization

Before diving into implementation details, it's important to understand the difference between authentication and authorization:

* **Authentication** is the process of verifying a user's identity. It answers the question: "Who are you?". This is typically done by checking credentials like a username and password, or through a third-party provider.

* **Authorization** is the process of granting or denying a user access to specific resources or actions. It answers the question: "What are you allowed to do?". This happens *after* a user has been successfully authenticated.

For example, when you log into an application, you are **authenticating**. When you try to access an admin-only page, the application checks if you are **authorized** to do so.

## Implementing Authentication

We strongly recommend using a dedicated third-party service to handle authentication. These services are built by security experts and are kept up-to-date with the latest security patches and best practices.

Recommended services:

* [Clerk](https://clerk.com/)
* [Auth0](https://auth0.com/)
* [Supabase Auth](https://supabase.com/auth)

If you prefer to manage authentication within your own infrastructure, you can use open-source packages like:

* [NextAuth.js](https://next-auth.js.org/) (for Next.js applications)
* [BetterAuth](https://better-auth.com/)

## Secure Your Endpoints

Every endpoint in your application should be secured. You should never assume that an endpoint will only be accessed by your frontend application.

For every request, you should:

1. **Authenticate:** Check if the request comes from a valid, authenticated user.
2. **Authorize:** Check if the authenticated user has the necessary permissions to perform the requested action or access the requested resource.

By default, deny all requests and only grant access to authenticated and authorized users.

## Vulnerability Scanning

Regularly scanning your application for vulnerabilities is a critical part of maintaining a secure application. These services automatically scan your application and alert you to potential security issues.

Recommended services:

* [Intruder.io](https://intruder.io/)
* [OWASP ZAP](https://www.zaproxy.org/) (Open-source)
* [Invicti](https://www.invicti.com/)
* [Acunetix](https://www.acunetix.com/)
* [Burp Suite](https://portswigger.net/burp)

## Secure Hosting and HTTPS

Using a managed hosting solution can help you with many aspects of security, including SSL/TLS termination, DDoS protection, and secure infrastructure.

Recommended hosting providers:

* [Vercel](https://vercel.com)
* [Netlify](https://www.netlify.com/)
* [Fly.io](https://fly.io/)

Always use **HTTPS** for your application. HTTPS encrypts the communication between your users and your server, preventing attackers from intercepting and reading sensitive data. All the recommended hosting providers make it easy to set up HTTPS.

## Other Security Best Practices

Here are some other basic security measures you should consider:

* **Input Validation and Sanitization:** Never trust user input. Always validate and sanitize any data received from users to prevent common vulnerabilities like Cross-Site Scripting (XSS) and SQL Injection.

* **Keep Dependencies Up-to-Date:** Use a tool like GitHub's Dependabot or Snyk to automatically scan your dependencies for known vulnerabilities and create pull requests to update them.

* **Principle of Least Privilege:** Grant users and services the minimum level of access they need to perform their functions.

* **Secure Error Handling:** Avoid leaking sensitive information in error messages. Generic error messages should be shown to the user, while detailed errors should be logged for developers to review.

* **Use Security Headers:** Implement security headers like Content Security Policy (CSP), Strict-Transport-Security (HSTS), and X-Frame-Options to protect your application from various attacks.


# n8n

# n8n Integration

The Fanvue n8n node allows you to integrate Fanvue API directly into your [n8n](https://n8n.io/) workflows. This community node provides access to various Fanvue resources, enabling you to automate tasks such as managing users, chats, followers, subscribers, and more.

Fanvue is a platform for content creators to monetize their content through subscriptions and direct interactions with fans.

## Installation

To install this node in your n8n instance:

1. Open your n8n instance
2. Go to **Settings** > **Community Nodes**
3. Click **Install**
4. Enter `@fanvue/n8n-nodes-fanvue`
5. Click **Install**

For alternative installation methods, see the [installation guide](https://docs.n8n.io/integrations/community-nodes/installation/) in the n8n community nodes documentation.

## Operations

This node provides access to all Fanvue API endpoints, organized by resource:

* **Users**: User profile and account management
* **Chats**: Messaging and chat operations
* **Followers**: Follower management
* **Subscribers**: Subscription handling
* **Creators**: Creator and agency operations
* **Media**: Media upload and management
* **Insights**: Analytics and statistics
* **Posts**: Content creation and management

## Credentials

This node uses OAuth2 authentication with the Fanvue API. You'll need to configure OAuth2 credentials in n8n with your Fanvue API client ID and secret.

## Compatibility

Tested with n8n version 1.0.0 and above.

## Usage

After installing the node and configuring credentials, you can access all Fanvue API operations through the node interface. The operations are organized by resource type for easy navigation.

## Resources

* [n8n community nodes documentation](https://docs.n8n.io/integrations/#community-nodes)
* [Fanvue API documentation](https://api.fanvue.com/docs)


# MCP (AI Assistants)

# MCP Integration

The Fanvue MCP (Model Context Protocol) server enables AI assistants like Claude and Cursor to interact directly with the Fanvue API. This integration allows you to use natural language to perform API operations, making it easier to build automations, manage content, and analyze data.

## What is MCP?

Model Context Protocol (MCP) is an open protocol that standardizes how AI assistants connect to external data sources and tools. The Fanvue MCP server exposes all Fanvue API endpoints as tools that AI assistants can call on your behalf.

## Installation

Install the Fanvue MCP server using pip or uvx:

```bash
pip install fanvue-mcp
```

Or run it directly without installation:

```bash
uvx fanvue-mcp
```

## Getting Started

### 1. Create an OAuth Application

First, you'll need OAuth credentials:

1. Visit the [Fanvue Developer Portal](https://www.fanvue.com/developers/apps)
2. Create a new application
3. Copy your Client ID and Client Secret

### 2. Configure Your AI Assistant

#### Cursor

Add to your Cursor MCP settings:

```json
{
  "mcpServers": {
    "fanvue": {
      "command": "uvx",
      "args": ["fanvue-mcp"],
      "env": {
        "FANVUE_CLIENT_ID": "your_client_id",
        "FANVUE_CLIENT_SECRET": "your_client_secret"
      }
    }
  }
}
```

#### Claude Code (VS Code Extension)

Add to your VS Code settings:

```json
{
  "claude.mcpServers": {
    "fanvue": {
      "command": "uvx",
      "args": ["fanvue-mcp"],
      "env": {
        "FANVUE_CLIENT_ID": "your_client_id",
        "FANVUE_CLIENT_SECRET": "your_client_secret"
      }
    }
  }
}
```

#### Claude Desktop

Add to your Claude Desktop config file:

**macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`\
**Windows**: `%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "fanvue": {
      "command": "uvx",
      "args": ["fanvue-mcp"],
      "env": {
        "FANVUE_CLIENT_ID": "your_client_id",
        "FANVUE_CLIENT_SECRET": "your_client_secret"
      }
    }
  }
}
```

Restart your AI assistant after saving the configuration.

## Usage Examples

Once configured, you can interact with the Fanvue API using natural language:

### Get Your Profile

```
"Show me my Fanvue profile information"
```

### Send Messages

```
"Send a message to user with UUID abc-123 saying 'Thanks for subscribing!'"
```

### Analyze Earnings

```
"What are my top 10 spenders this month?"
```

### Create Content

```
"Create a new post for subscribers with the text 'New content coming soon!'"
```

### Manage Followers

```
"List my most recent followers"
```

## Available Operations

The MCP server provides access to all Fanvue API endpoints:

* **Users**: Profile and account management
* **Chats**: Messaging and conversations
* **Posts**: Content creation and management
* **Media**: Upload and manage media files
* **Insights**: Analytics and earnings data
* **Creators**: Follower and subscriber management
* **Agencies**: Multi-creator management

## Authentication

The MCP server uses OAuth 2.0 for authentication. When you first use a tool that requires authentication, your AI assistant will prompt you to log in via your browser. The server handles token management automatically.

## Environment Variables

You can customize the server behavior with these environment variables:

* `FANVUE_CLIENT_ID`: Your OAuth Client ID (Required)
* `FANVUE_CLIENT_SECRET`: Your OAuth Client Secret (Required)
* `MCP_SERVER_PORT`: Server port (Default: 8080)
* `MCP_SERVER_URL`: Public URL for OAuth callbacks (Default: [http://localhost:8080](http://localhost:8080))
* `FANVUE_API_URL`: API base URL (Default: [https://api.fanvue.com](https://api.fanvue.com))
* `FANVUE_AUTH_URL`: Auth server URL (Default: [https://auth.fanvue.com](https://auth.fanvue.com))
* `DEBUG`: Enable debug logging (Default: false)

## Resources

* [MCP Server on PyPI](https://pypi.org/project/fanvue-mcp/)
* [Model Context Protocol Documentation](https://modelcontextprotocol.io/)
* [Fanvue API Documentation](https://api.fanvue.com/docs)
* [Developer Portal](https://www.fanvue.com/developers/apps)


# Get current user

GET https://api.fanvue.com/users/me

Get details of the currently authenticated user.

    <Info>Scope required: `read:self`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/users/get-current-user

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get current user
  version: endpoint_.getCurrentUser
paths:
  /users/me:
    get:
      operationId: get-current-user
      summary: Get current user
      description: |-
        Get details of the currently authenticated user.

            <Info>Scope required: `read:self`</Info>
      tags:
        - []
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: Current user details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/getCurrentUser_Response_200'
        '400':
          description: API version not supported
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    UsersMeGetResponsesContentApplicationJsonSchemaFanCounts:
      type: object
      properties:
        followersCount:
          type: number
          format: double
        subscribersCount:
          type: number
          format: double
      required:
        - followersCount
        - subscribersCount
    UsersMeGetResponsesContentApplicationJsonSchemaContentCounts:
      type: object
      properties:
        imageCount:
          type: number
          format: double
        videoCount:
          type: number
          format: double
        audioCount:
          type: number
          format: double
        postCount:
          type: number
          format: double
        payToViewPostCount:
          type: number
          format: double
      required:
        - imageCount
        - videoCount
        - audioCount
        - postCount
        - payToViewPostCount
    getCurrentUser_Response_200:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
        email:
          type: string
          format: email
        handle:
          type: string
        bio:
          type: string
        displayName:
          type: string
        isCreator:
          type: boolean
        createdAt:
          type: string
          format: date
        updatedAt:
          type: string
          format: date
        avatarUrl:
          type: string
          format: uri
        bannerUrl:
          type: string
          format: uri
        likesCount:
          type: number
          format: double
        fanCounts:
          $ref: >-
            #/components/schemas/UsersMeGetResponsesContentApplicationJsonSchemaFanCounts
        contentCounts:
          $ref: >-
            #/components/schemas/UsersMeGetResponsesContentApplicationJsonSchemaContentCounts
      required:
        - uuid
        - email
        - handle
        - bio
        - displayName
        - isCreator
        - createdAt
        - updatedAt

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/users/me"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/users/me';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/users/me"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/users/me")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/users/me")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/users/me', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/users/me");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/users/me")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get list of chats

GET https://api.fanvue.com/chats

Returns a paginated list of chat conversations with optional filtering, searching, and sorting.

**Available Filters** (via `filter` parameter):
- `unread` - Only unread chats
- `online` - Only online users
- `subscribed_to` - Users you're subscribed to
- `not_muted` - Exclude muted chats
- `subscribers` - Only subscribers (creator-only)
- `followers` - Only followers (creator-only)
- `recent_subscribers` - Recently subscribed (creator-only)
- `not_answered` - Unanswered chats (creator-only)
- `spent_more_than_50` - High spenders (creator-only)
- `on_free_trial` - Free trial users (creator-only)
- `has_tipped` - Users who have tipped (creator-only)
- `spenders` - All spenders (creator-only)
- `exclude_creators` - Exclude creator accounts (creator-only)

**Sort Options** (via `sortBy` parameter):
- `most_recent_messages` (default) - Sort by most recent message
- `online_now` - Prioritize online users
- `most_unanswered_chats` - Sort by unanswered count

<Info>Scope required: `read:chat`</Info>

<Warning>Some filters are only available to creators. Using creator-only filters as a non-creator will return a 403 error.</Warning>

Reference: https://api.fanvue.com/docs/api-reference/reference/chats/list-chats

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get list of chats
  version: endpoint_.listChats
paths:
  /chats:
    get:
      operationId: list-chats
      summary: Get list of chats
      description: >-
        Returns a paginated list of chat conversations with optional filtering,
        searching, and sorting.


        **Available Filters** (via `filter` parameter):

        - `unread` - Only unread chats

        - `online` - Only online users

        - `subscribed_to` - Users you're subscribed to

        - `not_muted` - Exclude muted chats

        - `subscribers` - Only subscribers (creator-only)

        - `followers` - Only followers (creator-only)

        - `recent_subscribers` - Recently subscribed (creator-only)

        - `not_answered` - Unanswered chats (creator-only)

        - `spent_more_than_50` - High spenders (creator-only)

        - `on_free_trial` - Free trial users (creator-only)

        - `has_tipped` - Users who have tipped (creator-only)

        - `spenders` - All spenders (creator-only)

        - `exclude_creators` - Exclude creator accounts (creator-only)


        **Sort Options** (via `sortBy` parameter):

        - `most_recent_messages` (default) - Sort by most recent message

        - `online_now` - Prioritize online users

        - `most_unanswered_chats` - Sort by unanswered count


        <Info>Scope required: `read:chat`</Info>


        <Warning>Some filters are only available to creators. Using creator-only
        filters as a non-creator will return a 403 error.</Warning>
      tags:
        - []
      parameters:
        - name: page
          in: query
          description: Page number to retrieve (starts from 1)
          required: false
          schema:
            type: number
            format: double
            default: 1
        - name: size
          in: query
          description: 'Number of items to return per page (1-50, default: 15)'
          required: false
          schema:
            type: number
            format: double
            default: 15
        - name: customListId
          in: query
          description: Filter chats by custom list UUID
          required: false
          schema:
            type: string
            format: uuid
        - name: smartListIds
          in: query
          description: Filter chats by smart list type(s)
          required: false
          schema:
            type: array
            items:
              $ref: '#/components/schemas/ChatsGetParametersSmartListIdsSchemaItems'
        - name: filter
          in: query
          description: Filter types to apply (can specify multiple via repeated params)
          required: false
          schema:
            type: array
            items:
              $ref: '#/components/schemas/ChatsGetParametersFilterSchemaItems'
        - name: search
          in: query
          description: Search term to filter chats by user name/handle
          required: false
          schema:
            type: string
        - name: sortBy
          in: query
          description: 'Sort order for chat list (default: most_recent_messages)'
          required: false
          schema:
            $ref: '#/components/schemas/ChatsGetParametersSortBy'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: List of chats
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/listChats_Response_200'
        '400':
          description: Bad Request - API version not supported OR validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsGetParametersSmartListIdsSchemaItems:
      type: string
      enum:
        - value: subscribers
        - value: auto_renewing
        - value: non_renewing
        - value: followers
        - value: free_trial_subscribers
        - value: expired_subscribers
        - value: spent_more_than_50
    ChatsGetParametersFilterSchemaItems:
      type: string
      enum:
        - value: unread
        - value: subscribers
        - value: followers
        - value: online
        - value: recent_subscribers
        - value: not_answered
        - value: spent_more_than_50
        - value: on_free_trial
        - value: has_tipped
        - value: spenders
        - value: exclude_creators
        - value: subscribed_to
        - value: not_muted
    ChatsGetParametersSortBy:
      type: string
      enum:
        - value: most_recent_messages
        - value: online_now
        - value: most_unanswered_chats
    ChatsGetResponsesContentApplicationJsonSchemaDataItemsUser:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
        handle:
          type: string
        displayName:
          type: string
        nickname:
          type:
            - string
            - 'null'
        isTopSpender:
          type: boolean
        avatarUrl:
          type:
            - string
            - 'null'
        registeredAt:
          type: string
          format: date
      required:
        - uuid
        - handle
        - displayName
        - nickname
        - isTopSpender
        - avatarUrl
        - registeredAt
    ChatsGetResponsesContentApplicationJsonSchemaDataItemsLastMessageType:
      type: string
      enum:
        - value: AUTOMATED_CANCELED
        - value: AUTOMATED_NEW_FOLLOWER
        - value: AUTOMATED_NEW_PURCHASE
        - value: AUTOMATED_NEW_SUBSCRIBER
        - value: AUTOMATED_RE_SUBSCRIBED
        - value: AUTOMATED_RENEWED
        - value: AUTOMATED_FIRST_MESSAGE_REPLY
        - value: AUTOMATED_CHAT_MESSAGE_REPLY
        - value: BROADCAST
        - value: CHAT_TEXT_GENERATION
        - value: CHAT_TEXT_REWRITE
        - value: CHAT_TEXT_REPLY
        - value: GHOST_PROMOTION
        - value: MARKETING_KYC
        - value: TIP
        - value: LOCKED_MESSAGE_UNLOCKED
        - value: VOICE_CALL
        - value: SINGLE_RECIPIENT
    ChatsGetResponsesContentApplicationJsonSchemaDataItemsLastMessageMediaType:
      type: string
      enum:
        - value: image
        - value: video
        - value: audio
    ChatsGetResponsesContentApplicationJsonSchemaDataItemsLastMessage:
      type: object
      properties:
        text:
          type:
            - string
            - 'null'
        type:
          $ref: >-
            #/components/schemas/ChatsGetResponsesContentApplicationJsonSchemaDataItemsLastMessageType
        uuid:
          type: string
        sentAt:
          type: string
          format: date
        hasMedia:
          type:
            - boolean
            - 'null'
        mediaType:
          oneOf:
            - $ref: >-
                #/components/schemas/ChatsGetResponsesContentApplicationJsonSchemaDataItemsLastMessageMediaType
            - type: 'null'
        senderUuid:
          type: string
          format: uuid
      required:
        - text
        - type
        - uuid
        - sentAt
        - hasMedia
        - mediaType
        - senderUuid
    ChatsGetResponsesContentApplicationJsonSchemaDataItems:
      type: object
      properties:
        createdAt:
          type: string
          format: date
        lastMessageAt:
          type:
            - string
            - 'null'
          format: date
          description: Date of the last message in this chat
        isRead:
          type: boolean
          description: Whether the chat is marked as read (true) or unread (false)
        isMuted:
          type: boolean
        unreadMessagesCount:
          type: number
          format: double
        user:
          $ref: >-
            #/components/schemas/ChatsGetResponsesContentApplicationJsonSchemaDataItemsUser
        lastMessage:
          oneOf:
            - $ref: >-
                #/components/schemas/ChatsGetResponsesContentApplicationJsonSchemaDataItemsLastMessage
            - type: 'null'
      required:
        - createdAt
        - lastMessageAt
        - isRead
        - isMuted
        - unreadMessagesCount
        - user
        - lastMessage
    ChatsGetResponsesContentApplicationJsonSchemaPagination:
      type: object
      properties:
        page:
          type: number
          format: double
          description: Current page number
        size:
          type: number
          format: double
          description: Number of records returned in this response
        hasMore:
          type: boolean
          description: Whether there are more items available on subsequent pages
      required:
        - page
        - size
        - hasMore
    listChats_Response_200:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsGetResponsesContentApplicationJsonSchemaDataItems
          description: Array of chat conversations
        pagination:
          $ref: >-
            #/components/schemas/ChatsGetResponsesContentApplicationJsonSchemaPagination
          description: Pagination information
      required:
        - data
        - pagination

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get unread chats, messages, and notifications count

GET https://api.fanvue.com/chats/unread

Returns the count of unread chats, total unread messages, and unread notifications by type for the authenticated user.

<Info>Scope required: `read:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chats/get-unread-chats-count

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get unread chats, messages, and notifications count
  version: endpoint_.getUnreadChatsCount
paths:
  /chats/unread:
    get:
      operationId: get-unread-chats-count
      summary: Get unread chats, messages, and notifications count
      description: >-
        Returns the count of unread chats, total unread messages, and unread
        notifications by type for the authenticated user.


        <Info>Scope required: `read:chat`</Info>
      tags:
        - []
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: Unread counts retrieved successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/getUnreadChatsCount_Response_200'
        '400':
          description: Bad Request - API version not supported OR validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsUnreadGetResponsesContentApplicationJsonSchemaUnreadNotifications:
      type: object
      properties:
        newFollower:
          type: number
          format: double
          description: Number of unread new follower notifications
        newPostComment:
          type: number
          format: double
          description: Number of unread post comment notifications
        newPostLike:
          type: number
          format: double
          description: Number of unread post like notifications
        newPurchase:
          type: number
          format: double
          description: Number of unread purchase notifications
        newSubscriber:
          type: number
          format: double
          description: Number of unread new subscriber notifications
        newTip:
          type: number
          format: double
          description: Number of unread tip notifications
        newPromotion:
          type: number
          format: double
          description: Number of unread promotion notifications
      required:
        - newFollower
        - newPostComment
        - newPostLike
        - newPurchase
        - newSubscriber
        - newTip
        - newPromotion
    getUnreadChatsCount_Response_200:
      type: object
      properties:
        unreadChatsCount:
          type: number
          format: double
          description: Number of conversations with unread messages
        unreadMessagesCount:
          type: number
          format: double
          description: Total number of unread messages across all chats
        unreadNotifications:
          $ref: >-
            #/components/schemas/ChatsUnreadGetResponsesContentApplicationJsonSchemaUnreadNotifications
          description: Counts of unread notifications by type
      required:
        - unreadChatsCount
        - unreadMessagesCount
        - unreadNotifications

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/unread"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/unread';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/unread"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/unread")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/unread")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/unread', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/unread");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/unread")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create a new chat

POST https://api.fanvue.com/chats
Content-Type: application/json

Create a new chat conversation with a user.

<Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chats/create-chat

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create a new chat
  version: endpoint_.createChat
paths:
  /chats:
    post:
      operationId: create-chat
      summary: Create a new chat
      description: |-
        Create a new chat conversation with a user.

        <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '201':
          description: Chat created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/createChat_Response_201'
        '400':
          description: >-
            Bad Request - API version not supported OR user contactability
            validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                userUuid:
                  type: string
                  format: uuid
              required:
                - userUuid
components:
  schemas:
    createChat_Response_201:
      type: object
      properties:
        message:
          type: string
      required:
        - message

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats"

payload = { "userUuid": "string" }
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats';
const options = {
  method: 'POST',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{"userUuid":"string"}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats"

	payload := strings.NewReader("{\n  \"userUuid\": \"string\"\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"userUuid\": \"string\"\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.fanvue.com/chats")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{\n  \"userUuid\": \"string\"\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.fanvue.com/chats', [
  'body' => '{
  "userUuid": "string"
}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats");
var request = new RestRequest(Method.POST);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"userUuid\": \"string\"\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = ["userUuid": "string"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get online statuses

POST https://api.fanvue.com/chats/statuses
Content-Type: application/json

Get online statuses for multiple users in a single request. This is useful for checking the online status of multiple chat counterparts at once.

<Info>Scope required: `read:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chats/get-online-statuses

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get online statuses
  version: endpoint_.getOnlineStatuses
paths:
  /chats/statuses:
    post:
      operationId: get-online-statuses
      summary: Get online statuses
      description: >-
        Get online statuses for multiple users in a single request. This is
        useful for checking the online status of multiple chat counterparts at
        once.


        <Info>Scope required: `read:chat`</Info>
      tags:
        - []
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: Online statuses for requested users
          content:
            application/json:
              schema:
                type: object
                additionalProperties:
                  $ref: >-
                    #/components/schemas/ChatsStatusesPostResponsesContentApplicationJsonSchema
        '400':
          description: Request validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                userUuids:
                  type: array
                  items:
                    type: string
                    format: uuid
                  description: Array of user UUIDs to check status for (max 100)
              required:
                - userUuids
components:
  schemas:
    ChatsStatusesPostResponsesContentApplicationJsonSchema:
      type: object
      properties:
        isOnline:
          type: boolean
          description: Whether the user is currently online
        lastSeenAt:
          type:
            - string
            - 'null'
          format: date-time
          description: When the user was last seen (null if never seen or not available)
      required:
        - isOnline
        - lastSeenAt

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/statuses"

payload = { "userUuids": ["string"] }
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/statuses';
const options = {
  method: 'POST',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{"userUuids":["string"]}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/statuses"

	payload := strings.NewReader("{\n  \"userUuids\": [\n    \"string\"\n  ]\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/statuses")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"userUuids\": [\n    \"string\"\n  ]\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.fanvue.com/chats/statuses")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{\n  \"userUuids\": [\n    \"string\"\n  ]\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.fanvue.com/chats/statuses', [
  'body' => '{
  "userUuids": [
    "string"
  ]
}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/statuses");
var request = new RestRequest(Method.POST);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"userUuids\": [\n    \"string\"\n  ]\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = ["userUuids": ["string"]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/statuses")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Update chat properties

PATCH https://api.fanvue.com/chats/{userUuid}
Content-Type: application/json

Update properties of a chat conversation with a user, such as read status, mute status, or nickname.

<Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chats/update-chat

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Update chat properties
  version: endpoint_.updateChat
paths:
  /chats/{userUuid}:
    patch:
      operationId: update-chat
      summary: Update chat properties
      description: >-
        Update properties of a chat conversation with a user, such as read
        status, mute status, or nickname.


        <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: userUuid
          in: path
          required: true
          schema:
            type: string
            format: uuid
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '204':
          description: Chat updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/updateChat_Response_204'
        '400':
          description: >-
            Bad Request - API version not supported OR validation failed OR
            invalid UUID
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                isRead:
                  type: boolean
                  description: >-
                    Whether the chat should be marked as read (true) or unread
                    (false)
                isMuted:
                  type: boolean
                  description: Whether the chat should be muted (true) or unmuted (false)
                nickname:
                  type: string
                  description: Custom nickname for the chat counterpart (max 30 characters)
components:
  schemas:
    updateChat_Response_204:
      type: object
      properties: {}

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/userUuid"

payload = {}
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.patch(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/userUuid';
const options = {
  method: 'PATCH',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/userUuid"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/userUuid")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Patch.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.patch("https://api.fanvue.com/chats/userUuid")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('PATCH', 'https://api.fanvue.com/chats/userUuid', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/userUuid");
var request = new RestRequest(Method.PATCH);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/userUuid")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get messages from a chat

GET https://api.fanvue.com/chats/{userUuid}/messages

Returns a paginated list of text messages between the authenticated user and the specified user. Messages are ordered by creation date (newest first).

    <Info>Scope required: `read:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-messages/list-messages

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get messages from a chat
  version: endpoint_.listMessages
paths:
  /chats/{userUuid}/messages:
    get:
      operationId: list-messages
      summary: Get messages from a chat
      description: >-
        Returns a paginated list of text messages between the authenticated user
        and the specified user. Messages are ordered by creation date (newest
        first).

            <Info>Scope required: `read:chat`</Info>
      tags:
        - []
      parameters:
        - name: userUuid
          in: path
          required: true
          schema:
            type: string
            format: uuid
        - name: page
          in: query
          description: Page number to retrieve (starts from 1)
          required: false
          schema:
            type: number
            format: double
            default: 1
        - name: size
          in: query
          description: 'Number of items to return per page (1-50, default: 15)'
          required: false
          schema:
            type: number
            format: double
            default: 15
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: List of messages
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/listMessages_Response_200'
        '400':
          description: >-
            Bad Request - API version not supported OR validation failed OR
            invalid UUID
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '404':
          description: No conversation found with the given user
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsSender:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
        handle:
          type: string
      required:
        - uuid
        - handle
    ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsRecipient:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
        handle:
          type: string
    ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsMediaType:
      type: string
      enum:
        - value: image
        - value: video
        - value: audio
    ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsType:
      type: string
      enum:
        - value: AUTOMATED_CANCELED
        - value: AUTOMATED_NEW_FOLLOWER
        - value: AUTOMATED_NEW_PURCHASE
        - value: AUTOMATED_NEW_SUBSCRIBER
        - value: AUTOMATED_RE_SUBSCRIBED
        - value: AUTOMATED_RENEWED
        - value: AUTOMATED_FIRST_MESSAGE_REPLY
        - value: AUTOMATED_CHAT_MESSAGE_REPLY
        - value: BROADCAST
        - value: CHAT_TEXT_GENERATION
        - value: CHAT_TEXT_REWRITE
        - value: CHAT_TEXT_REPLY
        - value: GHOST_PROMOTION
        - value: MARKETING_KYC
        - value: TIP
        - value: LOCKED_MESSAGE_UNLOCKED
        - value: VOICE_CALL
        - value: SINGLE_RECIPIENT
    ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItems:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
        text:
          type:
            - string
            - 'null'
        sentAt:
          type:
            - string
            - 'null'
          format: date
        sender:
          $ref: >-
            #/components/schemas/ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsSender
        recipient:
          $ref: >-
            #/components/schemas/ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsRecipient
        hasMedia:
          type:
            - boolean
            - 'null'
        mediaType:
          oneOf:
            - $ref: >-
                #/components/schemas/ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsMediaType
            - type: 'null'
        type:
          $ref: >-
            #/components/schemas/ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItemsType
      required:
        - uuid
        - text
        - sentAt
        - sender
        - recipient
        - hasMedia
        - mediaType
        - type
    ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaPagination:
      type: object
      properties:
        page:
          type: number
          format: double
          description: Current page number
        size:
          type: number
          format: double
          description: Number of records returned in this response
        hasMore:
          type: boolean
          description: Whether there are more items available on subsequent pages
      required:
        - page
        - size
        - hasMore
    listMessages_Response_200:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaDataItems
          description: Array of messages in the conversation
        pagination:
          $ref: >-
            #/components/schemas/ChatsUserUuidMessagesGetResponsesContentApplicationJsonSchemaPagination
          description: Pagination information
      required:
        - data
        - pagination

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/userUuid/messages"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/userUuid/messages';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/userUuid/messages"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/userUuid/messages")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/userUuid/messages")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/userUuid/messages', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/userUuid/messages");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/userUuid/messages")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Send a message

POST https://api.fanvue.com/chats/{userUuid}/message
Content-Type: application/json

Send a message to a user in an existing chat conversation. The message can include text, media attachments, and optional pricing for pay-to-view content.

    <Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-messages/send-message

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Send a message
  version: endpoint_.sendMessage
paths:
  /chats/{userUuid}/message:
    post:
      operationId: send-message
      summary: Send a message
      description: >-
        Send a message to a user in an existing chat conversation. The message
        can include text, media attachments, and optional pricing for
        pay-to-view content.

            <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: userUuid
          in: path
          required: true
          schema:
            type: string
            format: uuid
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '201':
          description: Message sent successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/sendMessage_Response_201'
        '400':
          description: >-
            Bad Request - API version not supported OR user contactability
            validation failed OR message validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                text:
                  type:
                    - string
                    - 'null'
                mediaUuids:
                  type: array
                  items:
                    type: string
                    format: uuid
                price:
                  type:
                    - number
                    - 'null'
                  format: double
                templateUuid:
                  type:
                    - string
                    - 'null'
                  format: uuid
components:
  schemas:
    sendMessage_Response_201:
      type: object
      properties:
        messageUuid:
          type: string
          format: uuid
      required:
        - messageUuid

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/userUuid/message"

payload = {}
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/userUuid/message';
const options = {
  method: 'POST',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/userUuid/message"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/userUuid/message")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.fanvue.com/chats/userUuid/message")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.fanvue.com/chats/userUuid/message', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/userUuid/message");
var request = new RestRequest(Method.POST);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/userUuid/message")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Send a mass message

POST https://api.fanvue.com/chats/mass-messages
Content-Type: application/json

Send a message to multiple users based on selected lists.

<Info>Scope required: `write:chat` `read:fan'</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-messages/send-mass-message

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Send a mass message
  version: endpoint_.sendMassMessage
paths:
  /chats/mass-messages:
    post:
      operationId: send-mass-message
      summary: Send a mass message
      description: |-
        Send a message to multiple users based on selected lists.

        <Info>Scope required: `write:chat` `read:fan'</Info>
      tags:
        - []
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '201':
          description: Mass message sent successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/sendMassMessage_Response_201'
        '400':
          description: >-
            Bad Request - API version not supported OR user contactability
            validation failed OR message validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                text:
                  type: string
                mediaUuids:
                  type: array
                  items:
                    type: string
                    format: uuid
                price:
                  type:
                    - number
                    - 'null'
                  format: double
                includedLists:
                  $ref: >-
                    #/components/schemas/ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaIncludedLists
                excludedLists:
                  $ref: >-
                    #/components/schemas/ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaExcludedLists
              required:
                - includedLists
components:
  schemas:
    ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaIncludedListsSmartListUuidsItems:
      type: string
      enum:
        - value: subscribers
        - value: auto_renewing
        - value: non_renewing
        - value: followers
        - value: free_trial_subscribers
        - value: expired_subscribers
        - value: spent_more_than_50
    ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaIncludedLists:
      type: object
      properties:
        smartListUuids:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaIncludedListsSmartListUuidsItems
        customListUuids:
          type: array
          items:
            type: string
            format: uuid
    ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaExcludedListsSmartListUuidsItems:
      type: string
      enum:
        - value: subscribers
        - value: auto_renewing
        - value: non_renewing
        - value: followers
        - value: free_trial_subscribers
        - value: expired_subscribers
        - value: spent_more_than_50
    ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaExcludedLists:
      type: object
      properties:
        smartListUuids:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsMassMessagesPostRequestBodyContentApplicationJsonSchemaExcludedListsSmartListUuidsItems
        customListUuids:
          type: array
          items:
            type: string
            format: uuid
    sendMassMessage_Response_201:
      type: object
      properties:
        id:
          type: string
          format: uuid
        recipientCount:
          type: number
          format: double
        createdAt:
          type: string
          format: date
      required:
        - id
        - recipientCount
        - createdAt

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/mass-messages"

payload = {}
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/mass-messages';
const options = {
  method: 'POST',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/mass-messages"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/mass-messages")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.fanvue.com/chats/mass-messages")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.fanvue.com/chats/mass-messages', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/mass-messages");
var request = new RestRequest(Method.POST);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/mass-messages")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete a message

DELETE https://api.fanvue.com/chats/{userUuid}/messages/{messageUuid}

Delete/unsend a previously sent message from a chat conversation.

Only the sender can delete their own messages. Messages that have been purchased (paid content) cannot be deleted. Mass messages cannot be deleted via this endpoint.

<Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-messages/delete-message

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete a message
  version: endpoint_.deleteMessage
paths:
  /chats/{userUuid}/messages/{messageUuid}:
    delete:
      operationId: delete-message
      summary: Delete a message
      description: >-
        Delete/unsend a previously sent message from a chat conversation.


        Only the sender can delete their own messages. Messages that have been
        purchased (paid content) cannot be deleted. Mass messages cannot be
        deleted via this endpoint.


        <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: userUuid
          in: path
          required: true
          schema:
            type: string
            format: uuid
        - name: messageUuid
          in: path
          required: true
          schema:
            type: string
            format: uuid
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '204':
          description: Message deleted successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/deleteMessage_Response_204'
        '400':
          description: Message cannot be deleted (e.g., purchased content)
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '404':
          description: Not Found Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    deleteMessage_Response_204:
      type: object
      properties: {}

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/userUuid/messages/messageUuid"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.delete(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/userUuid/messages/messageUuid';
const options = {
  method: 'DELETE',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/userUuid/messages/messageUuid"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/userUuid/messages/messageUuid")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.fanvue.com/chats/userUuid/messages/messageUuid")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.fanvue.com/chats/userUuid/messages/messageUuid', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/userUuid/messages/messageUuid");
var request = new RestRequest(Method.DELETE);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/userUuid/messages/messageUuid")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get list of template messages

GET https://api.fanvue.com/chats/templates

Returns a paginated list of template messages. Optionally filter by folder name using case-insensitive partial matching.

<Info>Scope required: `read:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-templates/list-template-messages

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get list of template messages
  version: endpoint_.listTemplateMessages
paths:
  /chats/templates:
    get:
      operationId: list-template-messages
      summary: Get list of template messages
      description: >-
        Returns a paginated list of template messages. Optionally filter by
        folder name using case-insensitive partial matching.


        <Info>Scope required: `read:chat`</Info>
      tags:
        - []
      parameters:
        - name: page
          in: query
          description: Page number to retrieve (starts from 1)
          required: false
          schema:
            type: number
            format: double
            default: 1
        - name: size
          in: query
          description: 'Number of items to return per page (1-50, default: 15)'
          required: false
          schema:
            type: number
            format: double
            default: 15
        - name: folderName
          in: query
          description: Filter by folder name (case-insensitive partial match)
          required: false
          schema:
            type: string
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: List of template messages
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/listTemplateMessages_Response_200'
        '400':
          description: Bad Request - API version not supported OR validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsTemplatesGetResponsesContentApplicationJsonSchemaDataItems:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
          description: Template message UUID
        text:
          type:
            - string
            - 'null'
          description: Message text content
        price:
          type:
            - number
            - 'null'
          format: double
          description: Message price in cents (null for free messages)
        mediaUuids:
          type: array
          items:
            type: string
            format: uuid
          description: Array of media UUIDs attached to the message
        folderName:
          type:
            - string
            - 'null'
          description: Name of the folder containing this template
      required:
        - uuid
        - text
        - price
        - mediaUuids
        - folderName
    ChatsTemplatesGetResponsesContentApplicationJsonSchemaPagination:
      type: object
      properties:
        page:
          type: number
          format: double
          description: Current page number
        size:
          type: number
          format: double
          description: Number of records returned in this response
        hasMore:
          type: boolean
          description: Whether there are more items available on subsequent pages
      required:
        - page
        - size
        - hasMore
    listTemplateMessages_Response_200:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsTemplatesGetResponsesContentApplicationJsonSchemaDataItems
          description: Array of template messages
        pagination:
          $ref: >-
            #/components/schemas/ChatsTemplatesGetResponsesContentApplicationJsonSchemaPagination
          description: Pagination information
      required:
        - data
        - pagination

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/templates"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/templates';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/templates"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/templates")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/templates")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/templates', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/templates");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/templates")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get a single template message

GET https://api.fanvue.com/chats/templates/{templateUuid}

Returns a specific template message by UUID.

<Info>Scope required: `read:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-templates/get-template-message

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get a single template message
  version: endpoint_.getTemplateMessage
paths:
  /chats/templates/{templateUuid}:
    get:
      operationId: get-template-message
      summary: Get a single template message
      description: |-
        Returns a specific template message by UUID.

        <Info>Scope required: `read:chat`</Info>
      tags:
        - []
      parameters:
        - name: templateUuid
          in: path
          description: Template message UUID
          required: true
          schema:
            type: string
            format: uuid
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: Template message details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/getTemplateMessage_Response_200'
        '400':
          description: >-
            Bad Request - API version not supported OR validation failed OR
            invalid UUID
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '404':
          description: Template message not found
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    getTemplateMessage_Response_200:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
          description: Template message UUID
        text:
          type:
            - string
            - 'null'
          description: Message text content
        price:
          type:
            - number
            - 'null'
          format: double
          description: Message price in cents (null for free messages)
        mediaUuids:
          type: array
          items:
            type: string
            format: uuid
          description: Array of media UUIDs attached to the message
        folderName:
          type:
            - string
            - 'null'
          description: Name of the folder containing this template
      required:
        - uuid
        - text
        - price
        - mediaUuids
        - folderName

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/templates/templateUuid"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/templates/templateUuid';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/templates/templateUuid"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/templates/templateUuid")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/templates/templateUuid")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/templates/templateUuid', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/templates/templateUuid");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/templates/templateUuid")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get smart lists

GET https://api.fanvue.com/chats/lists/smart

Get all available smart lists with member counts.

<Info>Scope required: `read:chat` `read:fan`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-smart-lists/get-smart-lists

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get smart lists
  version: endpoint_.getSmartLists
paths:
  /chats/lists/smart:
    get:
      operationId: get-smart-lists
      summary: Get smart lists
      description: |-
        Get all available smart lists with member counts.

        <Info>Scope required: `read:chat` `read:fan`</Info>
      tags:
        - []
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: List of smart lists
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: >-
                    #/components/schemas/ChatsListsSmartGetResponsesContentApplicationJsonSchemaItems
        '400':
          description: Bad Request - API version not supported OR validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsListsSmartGetResponsesContentApplicationJsonSchemaItemsUuid:
      type: string
      enum:
        - value: subscribers
        - value: auto_renewing
        - value: non_renewing
        - value: followers
        - value: free_trial_subscribers
        - value: expired_subscribers
        - value: spent_more_than_50
    ChatsListsSmartGetResponsesContentApplicationJsonSchemaItems:
      type: object
      properties:
        name:
          type: string
          description: Display name of the smart list
        uuid:
          $ref: >-
            #/components/schemas/ChatsListsSmartGetResponsesContentApplicationJsonSchemaItemsUuid
          description: Smart list unique identifier
        count:
          type: number
          format: double
          description: Number of members in this list
      required:
        - name
        - uuid
        - count

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/smart"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/smart';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/smart"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/smart")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/lists/smart")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/lists/smart', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/smart");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/smart")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get smart list members

GET https://api.fanvue.com/chats/lists/smart/{uuid}

Get members of a specific smart list with pagination.

<Info>Scope required: `read:chat` `read:fan`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-smart-lists/get-smart-list-members

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get smart list members
  version: endpoint_.getSmartListMembers
paths:
  /chats/lists/smart/{uuid}:
    get:
      operationId: get-smart-list-members
      summary: Get smart list members
      description: |-
        Get members of a specific smart list with pagination.

        <Info>Scope required: `read:chat` `read:fan`</Info>
      tags:
        - []
      parameters:
        - name: uuid
          in: path
          description: Smart list unique identifier
          required: true
          schema:
            $ref: '#/components/schemas/ChatsListsSmartUuidGetParametersUuid'
        - name: page
          in: query
          description: Page number to retrieve (starts from 1)
          required: false
          schema:
            type: number
            format: double
            default: 1
        - name: size
          in: query
          description: 'Number of items to return per page (1-50, default: 15)'
          required: false
          schema:
            type: number
            format: double
            default: 15
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: Smart list members
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/getSmartListMembers_Response_200'
        '400':
          description: Bad Request - API version not supported OR validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsListsSmartUuidGetParametersUuid:
      type: string
      enum:
        - value: subscribers
        - value: auto_renewing
        - value: non_renewing
        - value: followers
        - value: free_trial_subscribers
        - value: expired_subscribers
        - value: spent_more_than_50
    ChatsListsSmartUuidGetResponsesContentApplicationJsonSchemaDataItems:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
          description: User UUID
        displayName:
          type: string
          description: User's display name
        handle:
          type: string
          description: User's handle
        isCreator:
          type: boolean
          description: Whether user is a creator
      required:
        - uuid
        - displayName
        - handle
        - isCreator
    ChatsListsSmartUuidGetResponsesContentApplicationJsonSchemaPagination:
      type: object
      properties:
        page:
          type: number
          format: double
          description: Current page number
        size:
          type: number
          format: double
          description: Number of records returned in this response
        hasMore:
          type: boolean
          description: Whether there are more items available on subsequent pages
      required:
        - page
        - size
        - hasMore
    getSmartListMembers_Response_200:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsListsSmartUuidGetResponsesContentApplicationJsonSchemaDataItems
          description: Members of the smart list
        pagination:
          $ref: >-
            #/components/schemas/ChatsListsSmartUuidGetResponsesContentApplicationJsonSchemaPagination
          description: Pagination information
      required:
        - data
        - pagination

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/smart/subscribers"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/smart/subscribers';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/smart/subscribers"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/smart/subscribers")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/lists/smart/subscribers")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/lists/smart/subscribers', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/smart/subscribers");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/smart/subscribers")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get custom lists

GET https://api.fanvue.com/chats/lists/custom

Get user's custom lists with member counts. Supports pagination and optional name search.

<Info>Scope required: `read:chat` `read:fan`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-custom-lists/get-custom-lists

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get custom lists
  version: endpoint_.getCustomLists
paths:
  /chats/lists/custom:
    get:
      operationId: get-custom-lists
      summary: Get custom lists
      description: >-
        Get user's custom lists with member counts. Supports pagination and
        optional name search.


        <Info>Scope required: `read:chat` `read:fan`</Info>
      tags:
        - []
      parameters:
        - name: page
          in: query
          description: Page number to retrieve (starts from 1)
          required: false
          schema:
            type: number
            format: double
            default: 1
        - name: size
          in: query
          description: 'Number of items to return per page (1-50, default: 15)'
          required: false
          schema:
            type: number
            format: double
            default: 15
        - name: search
          in: query
          description: Search term to filter lists by name
          required: false
          schema:
            type: string
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: List of custom lists
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/getCustomLists_Response_200'
        '400':
          description: Bad Request - API version not supported OR validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsListsCustomGetResponsesContentApplicationJsonSchemaDataItems:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
          description: Custom list UUID
        name:
          type: string
          description: Custom list name
        membersCount:
          type: number
          format: double
          description: Number of members in this list
        createdAt:
          type: string
          format: date
          description: When the list was created
      required:
        - uuid
        - name
        - membersCount
        - createdAt
    ChatsListsCustomGetResponsesContentApplicationJsonSchemaPagination:
      type: object
      properties:
        page:
          type: number
          format: double
          description: Current page number
        size:
          type: number
          format: double
          description: Number of records returned in this response
        hasMore:
          type: boolean
          description: Whether there are more items available on subsequent pages
      required:
        - page
        - size
        - hasMore
    getCustomLists_Response_200:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsListsCustomGetResponsesContentApplicationJsonSchemaDataItems
          description: Array of custom lists
        pagination:
          $ref: >-
            #/components/schemas/ChatsListsCustomGetResponsesContentApplicationJsonSchemaPagination
          description: Pagination information
      required:
        - data
        - pagination

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/custom"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/custom';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/custom"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/custom")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/lists/custom")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/lists/custom', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/custom");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/custom")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get custom list members

GET https://api.fanvue.com/chats/lists/custom/{uuid}

Get members of a specific custom list with pagination.

<Info>Scope required: `read:chat` `read:fan`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-custom-lists/get-custom-list-members

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get custom list members
  version: endpoint_.getCustomListMembers
paths:
  /chats/lists/custom/{uuid}:
    get:
      operationId: get-custom-list-members
      summary: Get custom list members
      description: |-
        Get members of a specific custom list with pagination.

        <Info>Scope required: `read:chat` `read:fan`</Info>
      tags:
        - []
      parameters:
        - name: uuid
          in: path
          description: Custom list UUID
          required: true
          schema:
            type: string
            format: uuid
        - name: page
          in: query
          description: Page number to retrieve (starts from 1)
          required: false
          schema:
            type: number
            format: double
            default: 1
        - name: size
          in: query
          description: 'Number of items to return per page (1-50, default: 15)'
          required: false
          schema:
            type: number
            format: double
            default: 15
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '200':
          description: Custom list members
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/getCustomListMembers_Response_200'
        '400':
          description: >-
            Bad Request - API version not supported OR validation failed OR
            invalid UUID
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '404':
          description: Custom list not found
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    ChatsListsCustomUuidGetResponsesContentApplicationJsonSchemaDataItems:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
          description: User UUID
        displayName:
          type: string
          description: User's display name
        handle:
          type: string
          description: User's handle
        isCreator:
          type: boolean
          description: Whether user is a creator
      required:
        - uuid
        - displayName
        - handle
        - isCreator
    ChatsListsCustomUuidGetResponsesContentApplicationJsonSchemaPagination:
      type: object
      properties:
        page:
          type: number
          format: double
          description: Current page number
        size:
          type: number
          format: double
          description: Number of records returned in this response
        hasMore:
          type: boolean
          description: Whether there are more items available on subsequent pages
      required:
        - page
        - size
        - hasMore
    getCustomListMembers_Response_200:
      type: object
      properties:
        data:
          type: array
          items:
            $ref: >-
              #/components/schemas/ChatsListsCustomUuidGetResponsesContentApplicationJsonSchemaDataItems
          description: Members of the custom list
        pagination:
          $ref: >-
            #/components/schemas/ChatsListsCustomUuidGetResponsesContentApplicationJsonSchemaPagination
          description: Pagination information
      required:
        - data
        - pagination

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/custom/uuid"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.get(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/custom/uuid';
const options = {
  method: 'GET',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/custom/uuid"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/custom/uuid")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.fanvue.com/chats/lists/custom/uuid")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.fanvue.com/chats/lists/custom/uuid', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/custom/uuid");
var request = new RestRequest(Method.GET);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/custom/uuid")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create a custom list

POST https://api.fanvue.com/chats/lists/custom
Content-Type: application/json

Create a new custom list for organizing contacts.

<Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-custom-lists/create-custom-list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create a custom list
  version: endpoint_.createCustomList
paths:
  /chats/lists/custom:
    post:
      operationId: create-custom-list
      summary: Create a custom list
      description: |-
        Create a new custom list for organizing contacts.

        <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '201':
          description: Custom list created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/createCustomList_Response_201'
        '400':
          description: Bad Request - API version not supported OR validation failed
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '409':
          description: A list with this name already exists
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                  description: Name of the custom list
              required:
                - name
components:
  schemas:
    createCustomList_Response_201:
      type: object
      properties:
        uuid:
          type: string
          format: uuid
          description: UUID of the created list
        name:
          type: string
          description: Name of the created list
        createdAt:
          type: string
          format: date
          description: When the list was created
      required:
        - uuid
        - name
        - createdAt

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/custom"

payload = { "name": "string" }
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/custom';
const options = {
  method: 'POST',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{"name":"string"}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/custom"

	payload := strings.NewReader("{\n  \"name\": \"string\"\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/custom")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"name\": \"string\"\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.fanvue.com/chats/lists/custom")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{\n  \"name\": \"string\"\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.fanvue.com/chats/lists/custom', [
  'body' => '{
  "name": "string"
}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/custom");
var request = new RestRequest(Method.POST);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"name\": \"string\"\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = ["name": "string"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/custom")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Rename a custom list

PATCH https://api.fanvue.com/chats/lists/custom/{uuid}
Content-Type: application/json

Update the name of an existing custom list.

<Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-custom-lists/update-custom-list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Rename a custom list
  version: endpoint_.updateCustomList
paths:
  /chats/lists/custom/{uuid}:
    patch:
      operationId: update-custom-list
      summary: Rename a custom list
      description: |-
        Update the name of an existing custom list.

        <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: uuid
          in: path
          description: Custom list UUID
          required: true
          schema:
            type: string
            format: uuid
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '204':
          description: Custom list updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/updateCustomList_Response_204'
        '400':
          description: >-
            Bad Request - API version not supported OR validation failed OR
            invalid UUID
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '404':
          description: Custom list not found
          content: {}
        '409':
          description: A list with this name already exists
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                  description: New name for the custom list
              required:
                - name
components:
  schemas:
    updateCustomList_Response_204:
      type: object
      properties: {}

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/custom/uuid"

payload = { "name": "string" }
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.patch(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/custom/uuid';
const options = {
  method: 'PATCH',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{"name":"string"}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/custom/uuid"

	payload := strings.NewReader("{\n  \"name\": \"string\"\n}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/custom/uuid")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Patch.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"name\": \"string\"\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.patch("https://api.fanvue.com/chats/lists/custom/uuid")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{\n  \"name\": \"string\"\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('PATCH', 'https://api.fanvue.com/chats/lists/custom/uuid', [
  'body' => '{
  "name": "string"
}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/custom/uuid");
var request = new RestRequest(Method.PATCH);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"name\": \"string\"\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = ["name": "string"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/custom/uuid")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete a custom list

DELETE https://api.fanvue.com/chats/lists/custom/{uuid}

Delete a custom list. All members will be removed from the list.

<Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-custom-lists/delete-custom-list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete a custom list
  version: endpoint_.deleteCustomList
paths:
  /chats/lists/custom/{uuid}:
    delete:
      operationId: delete-custom-list
      summary: Delete a custom list
      description: |-
        Delete a custom list. All members will be removed from the list.

        <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: uuid
          in: path
          description: Custom list UUID
          required: true
          schema:
            type: string
            format: uuid
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '204':
          description: Custom list deleted successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/deleteCustomList_Response_204'
        '400':
          description: >-
            Bad Request - API version not supported OR validation failed OR
            invalid UUID
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '404':
          description: Custom list not found
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
components:
  schemas:
    deleteCustomList_Response_204:
      type: object
      properties: {}

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/custom/uuid"

headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>"
}

response = requests.delete(url, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/custom/uuid';
const options = {
  method: 'DELETE',
  headers: {'X-Fanvue-API-Version': '2025-06-26', Authorization: 'Bearer <token>'}
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/custom/uuid"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/custom/uuid")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.fanvue.com/chats/lists/custom/uuid")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.fanvue.com/chats/lists/custom/uuid', [
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/custom/uuid");
var request = new RestRequest(Method.DELETE);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>"
]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/custom/uuid")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Add members to a custom list

POST https://api.fanvue.com/chats/lists/custom/{uuid}/members
Content-Type: application/json

Add one or more users to a custom list. Existing members will be skipped.

<Info>Scope required: `write:chat`</Info>

Reference: https://api.fanvue.com/docs/api-reference/reference/chat-custom-list-members/add-members-to-custom-list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Add members to a custom list
  version: endpoint_.addMembersToCustomList
paths:
  /chats/lists/custom/{uuid}/members:
    post:
      operationId: add-members-to-custom-list
      summary: Add members to a custom list
      description: >-
        Add one or more users to a custom list. Existing members will be
        skipped.


        <Info>Scope required: `write:chat`</Info>
      tags:
        - []
      parameters:
        - name: uuid
          in: path
          description: Custom list UUID
          required: true
          schema:
            type: string
            format: uuid
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
        - name: X-Fanvue-API-Version
          in: header
          description: API version to use for the request
          required: true
          schema:
            type: string
            default: '2025-06-26'
      responses:
        '201':
          description: Members added successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/addMembersToCustomList_Response_201'
        '400':
          description: >-
            Bad Request - API version not supported OR validation failed OR
            invalid UUID
          content: {}
        '401':
          description: Unauthorized Response
          content: {}
        '403':
          description: Unauthorized Response
          content: {}
        '404':
          description: Custom list not found
          content: {}
        '410':
          description: API version no longer supported (sunset)
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                userUuids:
                  type: array
                  items:
                    type: string
                    format: uuid
                  description: UUIDs of users to add to the list (max 100)
              required:
                - userUuids
components:
  schemas:
    addMembersToCustomList_Response_201:
      type: object
      properties:
        added:
          type: number
          format: double
          description: Number of members added to the list
        skipped:
          type: number
          format: double
          description: Number of members skipped (already in list)
      required:
        - added
        - skipped

```

## SDK Code Examples

```python
import requests

url = "https://api.fanvue.com/chats/lists/custom/uuid/members"

payload = { "userUuids": ["string"] }
headers = {
    "X-Fanvue-API-Version": "2025-06-26",
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.post(url, json=payload, headers=headers)

print(response.json())
```

```javascript
const url = 'https://api.fanvue.com/chats/lists/custom/uuid/members';
const options = {
  method: 'POST',
  headers: {
    'X-Fanvue-API-Version': '2025-06-26',
    Authorization: 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: '{"userUuids":["string"]}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}
```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.fanvue.com/chats/lists/custom/uuid/members"

	payload := strings.NewReader("{\n  \"userUuids\": [\n    \"string\"\n  ]\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("X-Fanvue-API-Version", "2025-06-26")
	req.Header.Add("Authorization", "Bearer <token>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.fanvue.com/chats/lists/custom/uuid/members")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["X-Fanvue-API-Version"] = '2025-06-26'
request["Authorization"] = 'Bearer <token>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"userUuids\": [\n    \"string\"\n  ]\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.fanvue.com/chats/lists/custom/uuid/members")
  .header("X-Fanvue-API-Version", "2025-06-26")
  .header("Authorization", "Bearer <token>")
  .header("Content-Type", "application/json")
  .body("{\n  \"userUuids\": [\n    \"string\"\n  ]\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.fanvue.com/chats/lists/custom/uuid/members', [
  'body' => '{
  "userUuids": [
    "string"
  ]
}',
  'headers' => [
    'Authorization' => 'Bearer <token>',
    'Content-Type' => 'application/json',
    'X-Fanvue-API-Version' => '2025-06-26',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.fanvue.com/chats/lists/custom/uuid/members");
var request = new RestRequest(Method.POST);
request.AddHeader("X-Fanvue-API-Version", "2025-06-26");
request.AddHeader("Authorization", "Bearer <token>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"userUuids\": [\n    \"string\"\n  ]\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "X-Fanvue-API-Version": "2025-06-26",
  "Authorization": "Bearer <token>",
  "Content-Type": "application/json"
]
let parameters = ["userUuids": ["string"]] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.fanvue.com/chats/lists/custom/uuid/members")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```
